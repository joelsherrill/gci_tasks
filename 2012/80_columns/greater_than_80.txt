cpukit/libcsupport/include/sys/utsname.h:33:#define SYS_NMLN        32              /* uname(2) for the FreeBSD 1.1 ABI. */
cpukit/libcsupport/include/sys/utsname.h:41:  char sysname[SYS_NMLN];  /* Name of this implementation of the operating system */
cpukit/libcsupport/include/sys/statvfs.h:7: *  - http://www.opengroup.org/onlinepubs/009695399/basedefs/sys/statvfs.h.html
cpukit/libcsupport/include/rtc.h:50: * If the real-time clock provides an invalid time of day value the system time
cpukit/libcsupport/include/rtems/libio_.h:64: * The usage of this null location instead of the NULL pointer eliminates a lot
cpukit/libcsupport/include/rtems/libio_.h:71:extern rtems_filesystem_global_location_t rtems_filesystem_global_location_null;
cpukit/libcsupport/include/rtems/libio_.h:224:  rtems_semaphore_obtain( rtems_libio_semaphore, RTEMS_WAIT, RTEMS_NO_TIMEOUT );
cpukit/libcsupport/include/rtems/libio_.h:439: * @param[in, out] lhs_global_loc_ptr Pointer to the global left hand side file
cpukit/libcsupport/include/rtems/libio_.h:482: * @param[in] global_loc The global file system location.  It must not be NULL.
cpukit/libcsupport/include/rtems/malloc.h:177: * specifies the set of addresses which are aligned by the boundary value.  The
cpukit/libcsupport/include/rtems/malloc.h:184: * The memory allocated by this function can be released with a call to free().
cpukit/libcsupport/include/rtems/malloc.h:217: * specified by @a block_sizes.  The @a block_sizes must point to an array with
cpukit/libcsupport/include/rtems/error.h:26:#define RTEMS_ERROR_ERRNO  (1<<((sizeof(rtems_error_code_t) * CHAR_BIT) - 2)) /* hi bit; use 'errno' */
cpukit/libcsupport/include/rtems/error.h:27:#define RTEMS_ERROR_PANIC  (RTEMS_ERROR_ERRNO / 2)       /* err fatal; no return */
cpukit/libcsupport/include/rtems/error.h:28:#define RTEMS_ERROR_ABORT  (RTEMS_ERROR_ERRNO / 4)       /* err is fatal; panic */
cpukit/libcsupport/include/rtems/libio.h:224: * The caller must ensure that this location is protected from a release during
cpukit/libcsupport/include/rtems/libio.h:324: * The caller ensures that both nodes are within the same file system instance.
cpukit/libcsupport/include/rtems/libio.h:539: * @brief Terminates the path evaluation and replaces the current location with
cpukit/libcsupport/include/rtems/libio.h:789: * This handler is responsible to update the offset field of the IO descriptor.
cpukit/libcsupport/include/rtems/libio.h:809: * This handler is responsible to update the offset field of the IO descriptor.
cpukit/libcsupport/include/rtems/libio.h:1032: * @brief An offset 0 with a whence of SEEK_SET will perform a directory rewind
cpukit/libcsupport/include/rtems/libio.h:1160: * @brief Contain file system specific information which is required to support
cpukit/libcsupport/include/rtems/libio.h:1172:  int    posix_no_trunc;           /* error on names > max name, 0=no, 1=yes */
cpukit/libcsupport/include/rtems/libio.h:1191: * @todo Should really have a separate per/file data structure that this points
cpukit/libcsupport/include/rtems/libio.h:1196:  off_t                                   offset;    /* current offset into file */
cpukit/libcsupport/include/rtems/libio.h:1526: * return.  In case the calling thread has its root or current directory in the
cpukit/libcsupport/include/rtems/libio.h:1527: * unmounted file system the function returns with an error status and errno is
cpukit/libcsupport/include/rtems/libio.h:1530: * The unmount process completion notification uses the transient event.  It is
cpukit/libcsupport/include/rtems/libio.h:1652: * The iteration is protected by the IO library mutex.  Do not mount or unmount
cpukit/libcsupport/src/ftrylockfile.c:13:#if defined(RTEMS_NEWLIB) && !defined(HAVE_FTRYLOCKFILE) && defined(HAVE_DECL_FTRYLOCKFILE)
cpukit/libcsupport/src/statvfs.c:10: *    http://www.opengroup.org/onlinepubs/009695399/basedefs/sys/statvfs.h.html
cpukit/libcsupport/src/termios.c:487:    if ((tty->flow_ctrl & FL_IRTSOFF) && (tty->device.startRemoteTx != NULL)) {
cpukit/libcsupport/src/termios.c:929:  if (tty->termios.c_lflag & (ECHO|ECHOE|ECHOK|ECHONL|ECHOPRT|ECHOCTL|ECHOKE)) {
cpukit/libcsupport/src/termios.c:1208:        } else if ((tty->flow_ctrl & (FL_MDRTS | FL_IRTSOFF)) == (FL_MDRTS) ) {
cpukit/libcsupport/src/newlibc_exit.c:95: *      Called from exit() after it does atexit() processing and stdio fflush's
cpukit/libcsupport/src/utsname.c:35:  snprintf( name->nodename, sizeof(name->nodename), "Node %" PRId16, _Objects_Local_node );
cpukit/libcsupport/src/utsname.c:41:  snprintf( name->machine, sizeof(name->machine), "%s/%s", CPU_NAME, CPU_MODEL_NAME );
cpukit/libcsupport/src/chroot.c:35:   * We use the global environment for path evaluation.  This makes it possible
cpukit/libcsupport/src/fcntl.c:27:   * FIXME: We ignore the start value fd2 for the file descriptor search.  This
cpukit/libcsupport/src/fcntl.c:43:     * XXX: We call the open handler here to have a proper open and close pair.
cpukit/libcsupport/src/flockfile.c:13:#if defined(RTEMS_NEWLIB) && !defined(HAVE_FLOCKFILE) && defined(HAVE_DECL_FLOCKFILE)
cpukit/libcsupport/src/rtems_heap_greedy.c:29:  opaque = _Heap_Greedy_allocate( RTEMS_Malloc_Heap, block_sizes, block_count );
cpukit/libcsupport/src/envlock.c:23: *  - although it looks like a classical multiple-readers / single writer (MRSW)
cpukit/libcsupport/src/envlock.c:25: *     1) newlib has no provision / hook for calling different locking routines
cpukit/libcsupport/src/funlockfile.c:13:#if defined(RTEMS_NEWLIB) && !defined(HAVE_FUNLOCKFILE) && defined(HAVE_DECL_FUNLOCKFILE)
cpukit/libcsupport/src/assocnamebad.c:35:    sprintf(bad_buffer, "< %" PRId32 "[0x%" PRIx32 " ] >", bad_value, bad_value);
cpukit/libcsupport/src/sup_fs_location.c:60:rtems_filesystem_global_location_t *rtems_filesystem_location_transform_to_global(
cpukit/libcsupport/src/sup_fs_location.c:64:  rtems_filesystem_global_location_t *global_loc = malloc(sizeof(*global_loc));
cpukit/libcsupport/src/privateenv.c:76:          && !rtems_filesystem_global_location_is_null(new_env->current_directory)
cpukit/libcsupport/src/mount.c:34:const rtems_filesystem_limits_and_options_t rtems_filesystem_default_pathconf = {
cpukit/libcsupport/src/mount.c:88:    mt_entry->pathconf_limits_and_options = &rtems_filesystem_default_pathconf;
cpukit/libcsupport/src/mount.c:125:    mt_point_node = rtems_filesystem_location_transform_to_global( &targetloc );
cpukit/libcsupport/src/mount.c:204:      rtems_filesystem_mount_table_entry_t *mt_entry = alloc_mount_table_entry(
cpukit/libi2c/libi2c.c:71:#define MAX_NO_BUSSES	8       /* Also limited by the macro building minor numbers */
cpukit/libi2c/libi2c.c:72:#define MAX_NO_DRIVERS	16      /* Number of high level drivers we support          */
cpukit/libi2c/libi2c.c:122:#define LOCK(m)		assert(!rtems_semaphore_obtain((m), RTEMS_WAIT, RTEMS_NO_TIMEOUT))
cpukit/libi2c/libi2c.c:179:     * Nobody is holding the bus mutex - it's not there.  Create it on the fly.
cpukit/libi2c/libi2c.c:211:rtems_i2c_init (rtems_device_major_number major, rtems_device_minor_number minor,
cpukit/libi2c/libi2c.c:232:rtems_i2c_open (rtems_device_major_number major, rtems_device_minor_number minor,
cpukit/libi2c/libi2c.c:247:rtems_i2c_close (rtems_device_major_number major, rtems_device_minor_number minor,
cpukit/libi2c/libi2c.c:262:rtems_i2c_read (rtems_device_major_number major, rtems_device_minor_number minor,
cpukit/libi2c/libi2c.c:292:rtems_i2c_write (rtems_device_major_number major, rtems_device_minor_number minor,
cpukit/libi2c/libi2c.c:322:rtems_i2c_ioctl (rtems_device_major_number major, rtems_device_minor_number minor,
cpukit/libi2c/libi2c.c:365:  sc = rtems_io_register_driver (0, &rtems_libi2c_io_ops, &rtems_libi2c_major);
cpukit/libi2c/libi2c.c:400:    safe_printf ( DRVNM "Bad name: must be an absolute path starting with '/'\n");
cpukit/libi2c/libi2c.c:433:    safe_printf ( DRVNM "No bus-ops or size too small -- misconfiguration?\n");
cpukit/libi2c/libi2c.c:722:    safe_printf ( DRVNM "No driver table or size too small -- misconfiguration?\n");
cpukit/libi2c/libi2c.c:754:                   "Creating device node failed: %s; you can try to do it manually...\n",
cpukit/libi2c/libi2c.h:75:/* Initialize the libary - may fail if no semaphore or no driver slot is available */
cpukit/libi2c/libi2c.h:214:extern int rtems_libi2c_register_bus (const char *name, rtems_libi2c_bus_t * bus);
cpukit/libi2c/libi2c.h:234: *                  encoded in the minor number and read or write, respectively
cpukit/libi2c/libi2c.h:243: *   mknod("/dev/i2c-54", mode, MKDEV(rtems_libi2c_major, RTEMS_LIBI2C_MAKE_MINOR(0,0x54)))
cpukit/libi2c/libi2c.h:271: *    fd = open("/dev/i2c.eeprom",O_RDONLY) / * opens and sets EEPROM read pointer * /
cpukit/libi2c/libi2c.h:272: *    ioctl(fd, IOCTL_SEEK, 0x200)			/ * repositions the read pointer       * /
cpukit/libi2c/libi2c.h:298:  int size;                     /* size of whole structure (including appended private data) */
cpukit/libi2c/libi2c.h:324: *        thread could get into the protected sections (or would deadlock if the
cpukit/libi2c/libi2c.h:332: *        The correct way is to *always* relinquish the i2c bus (i.e., send 'stop'
cpukit/libi2c/libi2c.h:334: *		  Consult the implementation of the generic driver routines (open, close, ...)
cpukit/libi2c/libi2c.h:339:extern rtems_status_code rtems_libi2c_send_start (rtems_device_minor_number minor);
cpukit/libi2c/libi2c.h:341:extern rtems_status_code rtems_libi2c_send_stop (rtems_device_minor_number minor);
cpukit/libi2c/libi2c.h:425: *   tfr_mode is a pointer to a structure defining the SPI transfer mode needed
cpukit/libi2c/libi2c.h:467:  bool     clock_phs;      /* true: clock starts toggling at start of data tfr */
cpukit/libi2c/libi2c.h:468:  uint32_t  idle_char;     /* This character will be continuously transmitted in read only functions */
cpukit/telnetd/telnetd.h:94: * rtems_telnetd_initialize() to configure the Telnet subsystem.  Do not modify
cpukit/telnetd/telnetd.h:102: * Uses the application provided @ref rtems_telnetd_config configuration table.
cpukit/telnetd/des.c:145:static const u_char	ascii64[] = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
cpukit/telnetd/des.c:244:static const u_char	bits8[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
cpukit/telnetd/des.c:520:do_des(	u_int32_t l_in, u_int32_t r_in, u_int32_t *l_out, u_int32_t *r_out, int count, struct Des_Context *des_ctx)
cpukit/telnetd/des.c:851:  *pf = malloc(sizeof(struct fixed1) + sizeof(struct fixed2) + sizeof(struct fixed3) + sizeof(struct fixed4));
cpukit/telnetd/telnetd.c:145:static void release_a_Connection(char *devname, char *peername, FILE **pstd, int n)
cpukit/telnetd/telnetd.c:246:      devname = grab_a_Connection(des_socket, &srv, peername, sizeof(peername));
cpukit/telnetd/telnetd.c:370:         * sure the internal data are initialized (fileno(stdout) has this sideeffect).
cpukit/telnetd/telnetd.c:453:telnetd_dflt_spawn(const char *name, unsigned int priority, unsigned int stackSize, void (*fn)(void *), void* fnarg)
cpukit/sapi/include/confdefs.h:183:      #error "CONFIGURE_SMP_MAXIMUM_PROCESSORS not specified for SMP Application"
cpukit/sapi/include/confdefs.h:440:    int imfs_rq_memfile_bytes_per_block = CONFIGURE_IMFS_MEMFILE_BYTES_PER_BLOCK;
cpukit/sapi/include/confdefs.h:494:      static devFS_node devFS_root_filesystem_nodes [CONFIGURE_MAXIMUM_DEVICES];
cpukit/sapi/include/confdefs.h:528:  #warning "STACK_CHECKER_ON deprecated -- use CONFIGURE_STACK_CHECKER_ENABLED"
cpukit/sapi/include/confdefs.h:778:  #error "CONFIGURE_IDLE_TASK_STACK_SIZE less than CONFIGURE_MINIMUM_TASK_STACK_SIZE"
cpukit/sapi/include/confdefs.h:827:  #error "CONFIGURE_TASK_STACK_ALLOCATOR and CONFIGURE_TASK_STACK_DEALLOCATOR must be both defined or both undefined"
cpukit/sapi/include/confdefs.h:973:  #define CONFIGURE_INIT_TASK_NAME          rtems_build_name('U', 'I', '1', ' ')
cpukit/sapi/include/confdefs.h:998:  #define CONFIGURE_INIT_TASK_ARGUMENTS     ((rtems_task_argument) &bsp_boot_cmdline)
cpukit/sapi/include/confdefs.h:1170:    #define CONFIGURE_ATA_DRIVER_TASK_PRIORITY ATA_DRIVER_TASK_DEFAULT_PRIORITY
cpukit/sapi/include/confdefs.h:1274:    #error BDBUF Cache does not use a buffer configuration table. Please remove.
cpukit/sapi/include/confdefs.h:1327:          CONFIGURE_MP_MAXIMUM_GLOBAL_OBJECTS,    /* maximum # global objects */
cpukit/sapi/include/confdefs.h:1329:          CONFIGURE_EXTRA_MPCI_RECEIVE_SERVER_STACK, /* MPCI stack > minimum */
cpukit/sapi/include/confdefs.h:1330:          CONFIGURE_MP_MPCI_TABLE_POINTER         /* ptr to MPCI config table */
cpukit/sapi/include/confdefs.h:1334:      #define CONFIGURE_MULTIPROCESSING_TABLE    &Multiprocessing_configuration
cpukit/sapi/include/confdefs.h:1734:    #define CONFIGURE_MEMORY_FOR_POSIX_MESSAGE_QUEUE_DESCRIPTORS(_mqueue_fds) \
cpukit/sapi/include/confdefs.h:1819:          CONFIGURE_MAXIMUM_GO_CHANNELS + CONFIGURE_GO_INIT_CONDITION_VARIABLES) + \
cpukit/sapi/include/confdefs.h:1829:      CONFIGURE_MEMORY_FOR_POSIX_BARRIERS(CONFIGURE_MAXIMUM_POSIX_BARRIERS) + \
cpukit/sapi/include/confdefs.h:2216:  #error "CONFIGURE_EXECUTIVE_RAM_SIZE defined with request for CONFIGURE_EXTRA_MPCI_RECEIVE_SERVER_STACK"
cpukit/sapi/include/confdefs.h:2220:  #error "CONFIGURE_EXECUTIVE_RAM_SIZE defined with request for CONFIGURE_EXTRA_TASK_STACKS"
cpukit/sapi/include/confdefs.h:2312:    CONFIGURE_MICROSECONDS_PER_TICK,          /* microseconds per clock tick */
cpukit/sapi/include/confdefs.h:2314:    CONFIGURE_TICKS_PER_TIMESLICE,            /* ticks per timeslice quantum */
cpukit/sapi/include/confdefs.h:2322:    #ifdef CONFIGURE_UNIFIED_WORK_AREAS       /* true for unified work areas */
cpukit/sapi/include/confdefs.h:2337:    CONFIGURE_NUMBER_OF_INITIAL_EXTENSIONS,   /* number of static extensions */
cpukit/sapi/include/confdefs.h:2338:    CONFIGURE_INITIAL_EXTENSION_TABLE,        /* pointer to static extensions */
cpukit/sapi/include/confdefs.h:2517:    CONFIGURE_MEMORY_FOR_POSIX_SEMAPHORES( CONFIGURE_MAXIMUM_POSIX_SEMAPHORES ),
cpukit/sapi/include/confdefs.h:2617: *  These names have been obsoleted so make the user application stop compiling
cpukit/sapi/include/rtems/cbs.h:38:#define RTEMS_CBS_ERROR_MISSING_COMPONENT  SCHEDULER_CBS_ERROR_MISSING_COMPONENT
cpukit/sapi/include/rtems/cbs.h:39:#define RTEMS_CBS_ERROR_INCONSISTENT_STATE SCHEDULER_CBS_ERROR_INCONSISTENT_STATE
cpukit/sapi/include/rtems/config.h:162:   *  equal to the minimum stack size, then the IDLE task will have the minimum
cpukit/sapi/include/rtems/config.h:206:   * If this element is @a true, then the stack allocator must not allocate the
cpukit/sapi/include/rtems/rbheap.h:40: * the malloc() and free() interface.  It uses a first-fit allocation strategy.
cpukit/sapi/include/rtems/rbheap.h:42: * contained in the managed memory area.  Thus writing beyond the boundaries of
cpukit/sapi/include/rtems/rbheap.h:43: * a chunk does not damage the data to maintain the heap.  This can be used for
cpukit/sapi/include/rtems/rbheap.h:44: * example in a task stack allocator which protects the task stacks from access
cpukit/sapi/include/rtems/rbheap.h:45: * by other tasks.  The allocated and free memory parts of the managed area are
cpukit/sapi/include/rtems/rbheap.h:46: * called chunks.  Each chunk needs a descriptor which is stored outside of the
cpukit/sapi/include/rtems/rbheap.h:106:typedef void (*rtems_rbheap_extend_descriptors)(rtems_rbheap_control *control);
cpukit/sapi/include/rtems/rbheap.h:187: * @brief Frees a chunk of memory @a ptr allocated from the red-black tree heap
cpukit/sapi/include/rtems/rbheap.h:196: * @retval RTEMS_INCORRECT_STATE The chunk of memory is not in the right state.
cpukit/sapi/include/rtems/rbtree.h:69:  * field name of the rtems_rbtree_node structure in objects of @a object_type.
cpukit/sapi/include/rtems/extension.h:60: * typically perform a specific functionality such as performance monitoring or
cpukit/sapi/include/rtems/extension.h:66: * Configuration Table. This extension set is active for the entire life of the
cpukit/sapi/include/rtems/extension.h:76: * that they have a name, an ID, and can be dynamically created and deleted. In
cpukit/sapi/include/rtems/extension.h:101: * extension functions. It is also possible for a user extension to utilize the
cpukit/sapi/include/rtems/extension.h:129: * deallocated by the task delete extension when the task is deleted. Since the
cpukit/sapi/include/rtems/extension.h:154: * At the following system events, the extensions are invoked in reverse order:
cpukit/sapi/include/rtems/extension.h:162: * extension is invoked before the extension set it is built upon. For example,
cpukit/sapi/include/rtems/extension.h:177:typedef User_extensions_thread_restart_extension  rtems_task_restart_extension;
cpukit/sapi/include/rtems/extension.h:180:typedef User_extensions_thread_exitted_extension  rtems_task_exitted_extension;
cpukit/sapi/include/rtems/extension.h:222: * used to access this extension set in other extension set related directives.
cpukit/sapi/include/rtems/chain.h:100: * @brief Gets the first @a node of the @a chain and sends the @a events to the
cpukit/sapi/include/rtems/chain.h:116: * @brief Gets the first @a node of the @a chain and sends the @a events to the
cpukit/sapi/src/ioregisterdriver.c:98:    rtems_driver_address_table *const table = _IO_Driver_address_table + major;
cpukit/sapi/src/extensioncreate.c:52:  _User_extensions_Add_set_with_table( &the_extension->Extension, extension_table );
cpukit/sapi/src/rbheap.c:49:static int chunk_compare(const rtems_rbtree_node *a, const rtems_rbtree_node *b)
cpukit/sapi/src/rbheap.c:103:    if (begin < end && begin <= aligned_begin && aligned_begin < aligned_end) {
cpukit/sapi/src/rbheap.c:165:    rtems_rbheap_chunk *free_chunk = search_free_chunk(free_chain, aligned_size);
cpukit/sapi/src/rbheap.c:196:static rtems_rbheap_chunk *find(rtems_rbtree_control *chunk_tree, uintptr_t key)
cpukit/sapi/src/rbheap.c:270:void rtems_rbheap_extend_descriptors_with_malloc(rtems_rbheap_control *control)
cpukit/sapi/src/exinit.c:82:    _Configuration_MP_table = rtems_configuration_get_user_multiprocessing_table();
cpukit/sapi/src/posixapi.c:25:#include <rtems/system.h>    /* include this before checking RTEMS_POSIX_API */
cpukit/sapi/inline/rtems/chain.inl:21:# error "Never use <rtems/chain.inl> directly; include <rtems/chain.h> instead."
cpukit/sapi/inline/rtems/chain.inl:632: * This function removes the first node from the @a chain and returns a pointer
cpukit/sapi/inline/rtems/chain.inl:633: * to that node in @a node.  If the @a chain is empty, then @c NULL is returned.
cpukit/sapi/inline/rtems/timespec.inl:19:# error "Never use <rtems/timespec.inl> directly; include <rtems/timespec.h> instead."
cpukit/sapi/inline/rtems/rbtree.inl:19:# error "Never use <rtems/rbtree.inl> directly; include <rtems/rbtree.h> instead."
cpukit/sapi/inline/rtems/rbtree.inl:201: *  This function returns true if @a the_node is the min node on @a the_rbtree 
cpukit/sapi/inline/rtems/rbtree.inl:215: *  This function returns true if @a the_node is the max node on @a the_rbtree 
cpukit/sapi/inline/rtems/rbtree.inl:434:RTEMS_INLINE_ROUTINE rtems_rbtree_control *rtems_rbtree_find_header_unprotected(
cpukit/sapi/inline/rtems/rbtree.inl:474: *  @retval RBTree_Node* if one with equal key to the key of @a the_node exists
cpukit/include/rtems/status-checks.h:150: * @brief Prints message @a msg and returns with status code @a sc if the status
cpukit/include/rtems/status-checks.h:162: * @brief Prints message @a msg and returns with a return value of negative @a sc
cpukit/include/rtems/status-checks.h:174: * @brief Prints message @a msg and returns if the status code @a sc is not equal
cpukit/include/rtems/status-checks.h:211: * @brief Prints message @a msg and returns with status code @ref RTEMS_IO_ERROR
cpukit/include/rtems/status-checks.h:235: * @brief Prints message @a msg and delete the current task if the return value
cpukit/include/rtems/status-checks.h:269: * is not equal to @ref RTEMS_SUCCESSFUL.  The return value variable @a rv will
cpukit/include/rtems/status-checks.h:282: * @brief Prints message @a msg and jumps to @a label if the return value @a rv
cpukit/include/rtems/status-checks.h:294: * @brief Prints message @a msg and jumps to @a label if the return value @a rv
cpukit/include/rtems/status-checks.h:328: * @brief Prints message @a msg, sets the return value variable @a rv to @a val
cpukit/include/rtems/userenv.h:75:#define rtems_filesystem_current     (rtems_current_user_env->current_directory)
cpukit/include/rtems/userenv.h:88: * If the task has already a private environment nothing will be changed.  This
cpukit/include/rtems/userenv.h:89: * function must be called from normal thread context and may block on a mutex.
cpukit/include/rtems/userenv.h:103: * function must be called from normal thread context and may block on a mutex.
cpukit/include/rtems/userenv.h:106: * @param[in] task_id The private environment is shared with the task specified
cpukit/include/rtems/endian.h:167:static inline void rtems_uint16_to_little_endian( uint16_t value, uint8_t *data)
cpukit/include/rtems/endian.h:177:static inline void rtems_uint32_to_little_endian( uint32_t value, uint8_t *data)
cpukit/include/rtems/endian.h:187:static inline void rtems_uint64_to_little_endian( uint64_t value, uint8_t *data)
cpukit/include/rtems/pci.h:42:#define PCI_COMMAND_SPECIAL     0x0008  /* Enable response to special cycles */
cpukit/include/rtems/pci.h:52:#define PCI_STATUS_UDF              0x0040 /* Support User Definable Features */
cpukit/include/rtems/pci.h:127:#define PCI_SUBORDINATE_BUS    0x1a  /* Highest bus number behind the bridge */
cpukit/include/rtems/pci.h:128:#define PCI_SEC_LATENCY_TIMER  0x1b  /* Latency timer for secondary interface */
cpukit/include/rtems/pci.h:142:#define PCI_PREF_MEMORY_BASE       0x24  /* Prefetchable memory range behind */
cpukit/include/rtems/pci.h:148:#define PCI_PREF_BASE_UPPER32      0x28 /* Upper half of prefetchable memory */
cpukit/include/rtems/pci.h:156:#define PCI_BRIDGE_CTL_PARITY  0x01  /* Enable parity detection on secondary interface */
cpukit/include/rtems/pci.h:1188:  return BSP_pci_configuration.pci_functions->read_config_dword(bus, slot, function, where, val);
cpukit/include/rtems/irq.h:41:typedef void (*rtems_irq_enable)        (const struct __rtems_irq_connect_data__*);
cpukit/include/rtems/irq.h:42:typedef void (*rtems_irq_disable)       (const struct __rtems_irq_connect_data__*);
cpukit/include/rtems/irq.h:43:typedef int  (*rtems_irq_is_enabled)    (const struct __rtems_irq_connect_data__*);
cpukit/include/rtems/irq.h:123: * -------------------- RTEMS Single Irq Handler Mngt Routines ----------------
cpukit/include/rtems/irq.h:126: * function to connect a particular irq handler. This hanlder will NOT be called
cpukit/include/rtems/irq.h:167: * This function checks that the value given is the current one for safety reason.
cpukit/include/rtems/irq.h:187: * handler (config->irqHdlTbl[i].hdl)  different from "config->defaultEntry.hdl"
cpukit/include/rtems/irq-extension.h:124: * @brief Removes the interrupt handler routine @a handler with argument @a arg
cpukit/include/rtems/irq-extension.h:157: * @brief Iterates over all installed interrupt handler of the interrupt vector
cpukit/include/rtems/irq-extension.h:243: * @brief Removes the interrupt handler routine @a handler with argument @a arg
cpukit/include/rtems/fs.h:85:   * location to a list of deferred released locations.  This list is processed
cpukit/include/rtems/fs.h:91:   * A release within a critical section can happen multiple times.  This field
cpukit/libgnat/ada_intrsupp.c:113:  printk( "__gnat_interrupt_connect( %d, %p, %p )\n", vector, handler, parameter  );
cpukit/score/include/rtems/score/protectedheap.h:75: * @brief See _Heap_Allocate_aligned_with_boundary() with boundary equals zero.
cpukit/score/include/rtems/score/protectedheap.h:84:    _Protected_heap_Allocate_aligned_with_boundary( heap, size, alignment, 0 );
cpukit/score/include/rtems/score/object.h:473: *  @param[in] the_api indicates the API associated with this information block.
cpukit/score/include/rtems/score/object.h:641: *          successful or failure.  On success @a name will contain the name of
cpukit/score/include/rtems/score/object.h:701: *          successful or failure.  On success @a name will contain the name of
cpukit/score/include/rtems/score/scheduler.h:34: *  This handler encapsulates functionality related to managing sets of threads
cpukit/score/include/rtems/score/mppkt.h:61: *  This constant defines the first entry in the MP_packet_Classes enumeration.
cpukit/score/include/rtems/score/mppkt.h:91:  /** This field is the length of the data which required network conversion. */
cpukit/score/include/rtems/score/context.h:62:#define _Context_Initialize(_the_context, _stack, _size, _isr, _entry, _is_fp) \
cpukit/score/include/rtems/score/context.h:63:   _CPU_Context_Initialize( _the_context, _stack, _size, _isr, _entry, _is_fp )
cpukit/score/include/rtems/score/apiext.h:65:     * RTEMS data structures are initialized before device driver initialization
cpukit/score/include/rtems/score/watchdog.h:102:  /** This is the state when the watchdog is on a chain, and allowed to fire. */
cpukit/score/include/rtems/score/watchdog.h:142:  /** This field is the number of system clock ticks when this was scheduled. */
cpukit/score/include/rtems/score/watchdog.h:144:  /** This field is the number of system clock ticks when this was suspended. */
cpukit/score/include/rtems/score/states.h:74:/** This macro corresponds to a task waiting for a reply to an MPCI request. */
cpukit/score/include/rtems/score/coresem.h:58:  /** This specifies that threads will wait for the semaphore in FIFO order. */
cpukit/score/include/rtems/score/coresem.h:176: *  for a unit from this semaphore, then that task will be readied and the unit
cpukit/score/include/rtems/score/coresem.h:177: *  given to that task.  Otherwise, the unit will be returned to the semaphore.
cpukit/score/include/rtems/score/interr.h:186: * may install an initial extension that performs a system reset.  In this case
cpukit/score/include/rtems/score/timestamp.h:78: *  This method sets the timestamp to the specified @a _seconds and @a _nanoseconds
cpukit/score/include/rtems/score/timestamp.h:154: *  @return This method returns true if @a _lhs is greater than the @a _rhs and
cpukit/score/include/rtems/score/timestamp.h:289:  #define _Timestamp_Divide( _lhs, _rhs, _ival_percentage, _fval_percentage ) \
cpukit/score/include/rtems/score/timestamp.h:292:  #define _Timestamp_Divide( _lhs, _rhs, _ival_percentage, _fval_percentage ) \
cpukit/score/include/rtems/score/timestamp.h:293:          _Timestamp64_Divide( _lhs, _rhs, _ival_percentage, _fval_percentage )
cpukit/score/include/rtems/score/userextimpl.h:186:static inline void _User_extensions_Thread_restart( Thread_Control *restarted )
cpukit/score/include/rtems/score/userextimpl.h:221:static inline void _User_extensions_Thread_exitted( Thread_Control *executing )
cpukit/score/include/rtems/score/rbtree.h:26: *  The Red-Black Tree Handler is used to manage sets of entities.  This handler
cpukit/score/include/rtems/score/rbtree.h:249: *  This function returns a pointer called @a return_header to the control structure of the tree
cpukit/score/include/rtems/score/coremutex.h:61:  /** This specifies that threads will wait for the mutex in priority order.  */
cpukit/score/include/rtems/score/heap.h:45: * The alignment routines could be made faster should we require only powers of
cpukit/score/include/rtems/score/heap.h:56: * begin and end address.  The end address is not part of the set.  The size of
cpukit/score/include/rtems/score/heap.h:89: *   <tr><td>begin of allocated area (this field is page size aligned)</td></tr>
cpukit/score/include/rtems/score/heap.h:97: *   <tr><td>heap->area_begin</td><td colspan=2>heap area begin address</td></tr>
cpukit/score/include/rtems/score/heap.h:213:   * block.  The current block can use the @a prev_size field in the next block
cpukit/score/include/rtems/score/heap.h:421: * A page size of @a page_size and minimal block size of @a min_block_size will
cpukit/score/include/rtems/score/heap.h:426: * In case of success the pointers to the first and last block will be returned
cpukit/score/include/rtems/score/heap.h:446: * @c CPU_ALIGNMENT, it is aligned up to the nearest @c CPU_ALIGNMENT boundary.
cpukit/score/include/rtems/score/heap.h:472: * Returns the extended space available for allocation, or zero in case of failure.
cpukit/score/include/rtems/score/heap.h:507: * specifies the set of addresses which are aligned by the boundary value.  The
cpukit/score/include/rtems/score/heap.h:525: * @brief See _Heap_Allocate_aligned_with_boundary() with boundary equals zero.
cpukit/score/include/rtems/score/heap.h:540:RTEMS_INLINE_ROUTINE void *_Heap_Allocate( Heap_Control *heap, uintptr_t size )
cpukit/score/include/rtems/score/heap.h:600: * specified by @a block_sizes.  The @a block_sizes must point to an array with
cpukit/score/include/rtems/score/heap.h:716: * The block may be split up into multiple blocks.  The previous and next block
cpukit/score/include/rtems/score/heap.h:719: * block is used, they will be inserted after the free list head.  If the block
cpukit/score/include/rtems/score/coremsg.h:185:#define CORE_MESSAGE_QUEUE_STATUS_LAST CORE_MESSAGE_QUEUE_STATUS_UNSATISFIED_WAIT
cpukit/score/include/rtems/score/coremsg.h:194:  /** This field specifies the order in which blocking tasks will be ordered. */
cpukit/score/include/rtems/score/coremsg.h:325: *  @return This method returns the number of message pending messages flushed.
cpukit/score/include/rtems/score/coremsg.h:444: *  otherwise an error will be given to the thread if no messages are available.
cpukit/score/include/rtems/score/threadq.h:25: *  This handler encapsulates functionality related to managing sets of threads
cpukit/score/include/rtems/score/threadq.h:128: *  @param[in] the_thread is the pointer to a thread control block that is to be removed
cpukit/score/include/rtems/score/threadq.h:255:  _Thread_queue_Extract_priority_helper( _the_thread_queue, _the_thread, false )
cpukit/score/include/rtems/score/userext.h:138: * currently executing thread.  The second parameter points to the heir thread.
cpukit/score/include/rtems/score/userext.h:148: * executing thread may run with a minimal setup, for example with a freed task
cpukit/score/include/rtems/score/userext.h:225: * The switch control is part of the extensions control even if not used due to
cpukit/score/include/rtems/score/tod.h:181: *  @param[in] tod_as_timestamp is the constant of the time of day as a timestamp
cpukit/score/include/rtems/score/tod.h:266: *  This routine converts an interval expressed in milliseconds to microseconds.
cpukit/score/include/rtems/score/thread.h:119: *  then converted back to a pointer to void.  The result will compare equal to
cpukit/score/include/rtems/score/thread.h:156:typedef Thread ( *Thread_Entry_both_pointer_first )( void *, Thread_Entry_numeric_type );
cpukit/score/include/rtems/score/thread.h:162:typedef Thread ( *Thread_Entry_both_numeric_first )( Thread_Entry_numeric_type, void * );
cpukit/score/include/rtems/score/thread.h:265: *  The main purpose is to enable passing of pointers to read-only send buffers
cpukit/score/include/rtems/score/thread.h:306:  /** This field points to the thread queue on which this thread is blocked. */
cpukit/score/include/rtems/score/thread.h:475:  SCORE_EXTERN SMP_lock_spinlock_nested_Control _Thread_Dispatch_disable_level_lock;
cpukit/score/include/rtems/score/schedulercbs.h:107:   * @note: The current implementation of CBS handles only one task per server.
cpukit/score/include/rtems/score/schedulercbs.h:263: *  Retrieve time info relative to @a server_id. The server status code is returned.
cpukit/score/include/rtems/score/threadmp.h:37: *  This routine initializes the multiprocessing portion of the Thread Handler.
cpukit/score/include/rtems/score/threadsync.h:22: *  @defgroup ScoreThreadSync Thread Blocking Operation Synchronization Handler
cpukit/score/include/rtems/score/timestamp64.h:292:    _Timestamp64_implementation_Divide_by_integer( _time, _iterations, _result )
cpukit/score/include/rtems/score/corespinlock.h:43:  /** This status indicates that the current thread already holds the spinlock.
cpukit/score/include/rtems/score/isr.h:72: *  the current CPU being used.  This is usually the number of distinct vectors
cpukit/score/include/rtems/score/isr.h:80:#define ISR_INTERRUPT_MAXIMUM_VECTOR_NUMBER  CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER
cpukit/score/src/rbtreeinsert.c:57:      /* now rotate grandparent in the other branch direction (toward uncle) */
cpukit/score/src/rbtreeinsert.c:72: *  @retval RBTree_Node* if one with equal key to the key of @a the_node exists
cpukit/score/src/corebarrierrelease.c:36:  CORE_barrier_API_mp_support_callout  api_barrier_mp_support __attribute__((unused))
cpukit/score/src/schedulercbsreleasejob.c:41:      new_priority = (_Watchdog_Ticks_since_boot + serv_info->parameters.deadline)
cpukit/score/src/userext.c:62:    User_extensions_Switch_context ctx = { initial_extension_switch_controls };
cpukit/score/src/mpci.c:223:    _Thread_queue_Enqueue( &_MPCI_Remote_blocked_threads, the_packet->timeout );
cpukit/score/src/threaddispatch.c:78:     * means task L executes now although task H is ready!  Task H will execute
cpukit/score/src/threaddispatch.c:118:    if ( heir->budget_algorithm == THREAD_CPU_BUDGET_ALGORITHM_RESET_TIMESLICE )
cpukit/score/src/threaddispatch.c:157:     *  to context switch between floating point tasks.  The deferred algorithm
cpukit/score/src/threadqprocesstimeout.c:48:  if ( the_thread_queue->sync_state != THREAD_BLOCKING_OPERATION_SYNCHRONIZED &&
cpukit/score/src/threadqprocesstimeout.c:50:    if ( the_thread_queue->sync_state != THREAD_BLOCKING_OPERATION_SATISFIED ) {
cpukit/score/src/isr.c:70:  _CPU_Interrupt_stack_setup(_CPU_Interrupt_stack_low, _CPU_Interrupt_stack_high);
cpukit/score/src/coremsginsert.c:55:        _CORE_message_queue_Append_unprotected(the_message_queue, the_message);
cpukit/score/src/coremsginsert.c:57:        _CORE_message_queue_Prepend_unprotected(the_message_queue, the_message);
cpukit/score/src/coremsginsert.c:64:        _CORE_message_queue_Append_unprotected(the_message_queue, the_message);
cpukit/score/src/coremsginsert.c:70:        _CORE_message_queue_Prepend_unprotected(the_message_queue, the_message);
cpukit/score/src/coremsginsert.c:86:        this_priority = _CORE_message_queue_Get_message_priority(this_message);
cpukit/score/src/coremsginsert.c:109:      (*the_message_queue->notify_handler)(the_message_queue->notify_argument);
cpukit/score/src/objectinitializeinformation.c:109:    _Objects_Build_id( the_api, the_class, _Objects_Local_node, minimum_index );
cpukit/score/src/coremsg.c:70:   * If not, it will increase allocated_message_size to multiplicity of pointer
cpukit/score/src/coremsg.c:79:   * Check for an overflow. It can occur while increasing allocated_message_size
cpukit/score/src/schedulercbsgetremainingbudget.c:39:    *remaining_budget = _Scheduler_CBS_Server_list[server_id]->parameters.budget;
cpukit/score/src/heapallocate.c:224:       * The HEAP_PREV_BLOCK_USED flag is always set in the block size_and_flag
cpukit/score/src/ts64dividebyinteger.c:30:  _Timestamp64_implementation_Divide_by_integer( _time, _iterations, _result );
cpukit/score/src/threadmp.c:69:    the_proxy->Object.id = _MPCI_Receive_server_tcb->receive_packet->source_tid;
cpukit/score/src/heapfree.c:91:      Heap_Block *const next = block->Protection_begin.next_delayed_free_block;
cpukit/score/src/heapfree.c:118:   * is a special case that could be handled by the in heap check how-ever that
cpukit/score/src/coremsgseize.c:115:    executing->Wait.return_code = CORE_MESSAGE_QUEUE_STATUS_UNSATISFIED_NOWAIT;
cpukit/score/src/smp.c:86:    level = _SMP_lock_spinlock_simple_Obtain( &_Per_CPU_Information[cpu].lock );
cpukit/score/src/smp.c:93:    _SMP_lock_spinlock_simple_Release( &_Per_CPU_Information[cpu].lock, level );
cpukit/score/src/smp.c:132:    _SMP_lock_spinlock_simple_Release( &_Per_CPU_Information[cpu].lock, level );
cpukit/score/src/smp.c:143:    _SMP_lock_spinlock_simple_Release( &_Per_CPU_Information[cpu].lock, level );
cpukit/score/src/smp.c:157:    _SMP_lock_spinlock_simple_Release( &_Per_CPU_Information[cpu].lock, level );
cpukit/score/src/smp.c:195:    level = _SMP_lock_spinlock_simple_Obtain( &_Per_CPU_Information[cpu].lock );
cpukit/score/src/smp.c:197:    _SMP_lock_spinlock_simple_Release( &_Per_CPU_Information[cpu].lock, level );
cpukit/score/src/coremsgbroadcast.c:39:    CORE_message_queue_API_mp_support_callout  api_message_queue_mp_support __attribute__((unused)),
cpukit/score/src/threadchangepriority.c:44:   * Set a transient state for the thread so it is pulled off the Ready chains.
cpukit/score/src/coremsgsubmit.c:39:    CORE_message_queue_API_mp_support_callout  api_message_queue_mp_support  __attribute__((unused)),
cpukit/score/src/heapextend.c:65:  new_first_block->size_and_flag = new_first_block_size | HEAP_PREV_BLOCK_USED;
cpukit/score/src/schedulersimplereadyqueueenqueuefirst.c:54:  _Chain_Insert_unprotected( (Chain_Node *)current, &the_thread->Object.Node );
cpukit/score/src/rbtreeextract.c:123:   * check if both children are non-null, if so then we must find a target node
cpukit/score/src/rbtreeextract.c:130:    target = the_node->child[RBT_LEFT]; /* find max in node->child[RBT_LEFT] */
cpukit/score/src/coremsgflushsupp.c:72:    message_queue_first = _Chain_First( &the_message_queue->Pending_messages );
cpukit/score/src/schedulercbsallocate.c:40:    schinfo->edf_per_thread.queue_state = SCHEDULER_EDF_QUEUE_STATE_NEVER_HAS_BEEN;
cpukit/score/src/schedulerpriority.c:30:Priority_bit_map_Control          _Priority_Bit_map[16] CPU_STRUCTURE_ALIGNMENT;
cpukit/score/src/corebarrierwait.c:46:      executing->Wait.return_code = CORE_BARRIER_STATUS_AUTOMATICALLY_RELEASED;
cpukit/score/src/threadhandler.c:153:    else if ( executing->Start.prototype == THREAD_START_BOTH_POINTER_FIRST ) {
cpukit/score/src/threadhandler.c:160:    else if ( executing->Start.prototype == THREAD_START_BOTH_NUMERIC_FIRST ) {
cpukit/score/src/heapwalk.c:229:    _Heap_Block_at( last_block, _Heap_Block_size( last_block ) ) != first_block
cpukit/score/src/heapresizeblock.c:100:  Heap_Block *const block = _Heap_Block_of_alloc_area( alloc_begin, page_size );
cpukit/score/src/heap.c:248:    heap->Protection.block_initialize = _Heap_Protection_block_initialize_default;
cpukit/score/src/objectnametoidstring.c:63:      if (!strncmp( name, the_object->name.name_p, information->name_length)) {
cpukit/score/src/objectextendinformation.c:188:              (information->maximum + minimum_index) * sizeof(Objects_Control *) );
cpukit/score/src/objectextendinformation.c:253:  while ((the_object = (Objects_Control *) _Chain_Get( &Inactive )) != NULL ) {
cpukit/score/src/coremutexsurrender.c:99:  CORE_mutex_API_mp_support_callout  api_mutex_mp_support __attribute__((unused))
cpukit/score/src/schedulersimplereadyqueueenqueue.c:50:  _Chain_Insert_unprotected( (Chain_Node *)current, &the_thread->Object.Node );
cpukit/score/src/objectfree.c:57:    if ( information->inactive > ( allocation_size + ( allocation_size >> 1 ) ) ) {
cpukit/score/src/thread.c:104:    false,                      /* true if names for this object are strings */
cpukit/score/cpu/mips/cpu.c:58:** Exception stack frame pointer used in cpu_asm to pass the exception stack frame
cpukit/score/cpu/mips/cpu.c:88:  _CPU_Null_fp_context.fpcs = 0x1000000; 	/* Set FS flag in floating point coprocessor
cpukit/score/cpu/mips/cpu.c:133:  mips_set_sr( (sr & ~SR_IE) );                 /* first disable ie bit (recommended) */
cpukit/score/cpu/mips/rtems/score/cpu.h:327:/* __MIPSEB__ or __MIPSEL__ is defined by GCC based on -EB or -EL command line options */
cpukit/score/cpu/mips/rtems/score/cpu.h:394:/* WARNING: If this structure is modified, the constants in cpu.h must be updated. */
cpukit/score/cpu/mips/rtems/score/cpu.h:588:  __MIPS_REGISTER_TYPE  prid;     /* 79 -- NOT FILLED IN (not need to do so) */
cpukit/score/cpu/mips/rtems/score/cpu.h:589:  __MIPS_REGISTER_TYPE  tar ;     /* 80 -- target address register, filled on exceptions */
cpukit/score/cpu/mips/rtems/score/cpu.h:652:#define CPU_INTERRUPT_NUMBER_OF_VECTORS      (mips_interrupt_number_of_vectors)
cpukit/score/cpu/mips/rtems/score/cpu.h:653:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/mips/rtems/score/cpu.h:744:    mips_set_sr( (_scratch & ~SR_INTERRUPT_ENABLE_BITS) | (_level & SR_INTERRUPT_ENABLE_BITS) ); \
cpukit/score/cpu/mips/rtems/score/cpu.h:816: *  interrupt bits; bit 0 applies to the mips1 IEC bit/mips3 EXL&IE, bits 1 thru 6
cpukit/score/cpu/mips/rtems/score/cpu.h:835:#define _EXTRABITS      0  /* make sure we're in user mode on MIPS1 processors */
cpukit/score/cpu/lm32/irq.c:75:  if ( _Thread_Dispatch_necessary && !_Thread_Dispatch_in_critical_section() ) {
cpukit/score/cpu/lm32/rtems/score/cpu.h:598:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/lm32/rtems/score/cpu.h:647: *         On byte oriented architectures, @ref CPU_HEAP_ALIGNMENT normally will
cpukit/score/cpu/lm32/rtems/score/cpu.h:648: *         have to be greater or equal to than @ref CPU_ALIGNMENT to ensure that
cpukit/score/cpu/lm32/rtems/score/cpu.h:693: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/lm32/rtems/score/cpu.h:732: *  This temporarily restores the interrupt to @a _isr_cookie before immediately
cpukit/score/cpu/lm32/rtems/score/cpu.h:883: *    -# putting a "null FP status word" in the correct place in the FP context.
cpukit/score/cpu/lm32/rtems/asm.h:86:/** This macro is used to denote the beginning of a data declaration section. */
cpukit/score/cpu/sparc/cpu.c:51: *        The SPARC's assembly code can reference it directly with no problems.
cpukit/score/cpu/sparc/rtems/score/cpu.h:296:  /** This field pads the structure so ldd and std instructions can be used. */
cpukit/score/cpu/sparc/rtems/score/cpu.h:430:  /** This will contain the contents of the i6 (e.g. frame pointer) register. */
cpukit/score/cpu/sparc/rtems/score/cpu.h:447:  /** This will contain the contents of the o6 (e.g. frame pointer) register. */
cpukit/score/cpu/sparc/rtems/score/cpu.h:857: * This macro returns the real hardware vector number associated with @a _trap.
cpukit/score/cpu/sparc/rtems/score/cpu.h:935: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/sparc/rtems/asm.h:44:/* XXX __USER_LABEL_PREFIX__ and __REGISTER_PREFIX__ do not work on gcc 2.7.0 */
cpukit/score/cpu/sparc/rtems/asm.h:45:/* XXX The following ifdef magic fixes the problem but results in a warning   */
cpukit/score/cpu/sparc/rtems/asm.h:46:/* XXX when compiling assembly code.                                          */
cpukit/score/cpu/h8300/rtems/score/cpu.h:480:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/h8300/rtems/score/cpu.h:573: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/h8300/rtems/score/cpu.h:592:    __asm__ volatile( "stc.w ccr, @-er7 ;\n orc #0xC0,ccr ;\n mov.w @er7+,%0" :  : "r" (_isr_cookie) ); \
cpukit/score/cpu/h8300/rtems/score/cpu.h:605:    __asm__ volatile( "mov.w %0,@-er7 ;\n ldc.w @er7+, ccr" :  : "r" (_isr_cookie) ); \
cpukit/score/cpu/h8300/rtems/score/cpu.h:619:    __asm__ volatile( "mov.w %0,@-er7 ;\n ldc.w @er7+, ccr ;\n orc #0xC0,ccr" :  : "r" (_isr_cookie) ); \
cpukit/score/cpu/sparc64/cpu.c:35: *        The SPARC's assembly code can reference it directly with no problems.
cpukit/score/cpu/sparc64/cpu.c:89:    the_context->o6_sp = stack_high - CPU_MINIMUM_STACK_FRAME_SIZE - STACK_BIAS;
cpukit/score/cpu/sparc64/rtems/score/sparc64.h:181:     __asm__ volatile( "rdpr %%pstate, %0" :  "=r" (_pstate) : "0" (_pstate) ); \
cpukit/score/cpu/sparc64/rtems/score/sparc64.h:202:    __asm__ volatile ( "wrpr  %%g0, %0, %%pil " : "=r" ((_pil)) : "0" ((_pil)) ); \
cpukit/score/cpu/sparc64/rtems/score/cpu.h:552:#define CONTEXT_CONTROL_INTERRUPT_FRAME_SIZE CPU_MINIMUM_STACK_FRAME_SIZE + 0xA8 
cpukit/score/cpu/sparc64/rtems/score/cpu.h:764: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/sparc64/rtems/asm.h:47:/* XXX __USER_LABEL_PREFIX__ and __REGISTER_PREFIX__ do not work on gcc 2.7.0 */
cpukit/score/cpu/sparc64/rtems/asm.h:48:/* XXX The following ifdef magic fixes the problem but results in a warning   */
cpukit/score/cpu/sparc64/rtems/asm.h:49:/* XXX when compiling assembly code.                                          */
cpukit/score/cpu/m32c/rtems/score/cpu.h:558:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/m32c/rtems/score/cpu.h:609: *         On byte oriented architectures, @ref CPU_HEAP_ALIGNMENT normally will
cpukit/score/cpu/m32c/rtems/score/cpu.h:610: *         have to be greater or equal to than @ref CPU_ALIGNMENT to ensure that
cpukit/score/cpu/m32c/rtems/score/cpu.h:644: *  @note This must be a power of 2 either 0 or greater than @ref CPU_ALIGNMENT.
cpukit/score/cpu/m32c/rtems/score/cpu.h:658: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/m32c/rtems/score/cpu.h:705: *  This temporarily restores the interrupt to @a _isr_cookie before immediately
cpukit/score/cpu/m32c/rtems/score/cpu.h:857: *    -# putting a "null FP status word" in the correct place in the FP context.
cpukit/score/cpu/m32c/rtems/asm.h:86:/** This macro is used to denote the beginning of a data declaration section. */
cpukit/score/cpu/i386/cpu.c:85:      printk("PANIC: RTEMS was compiled for SSE but BSP did not enable it (CR4: 0x%08x)\n", cr4);
cpukit/score/cpu/i386/sse_test.c:161:#define MXCSR_ALLM (MXCSR_PM | MXCSR_UM | MXCSR_OM | MXCSR_ZM | MXCSR_DM | MXCSR_IM)
cpukit/score/cpu/i386/sse_test.c:162:#define MXCSR_ALLE (MXCSR_PE | MXCSR_UE | MXCSR_OE | MXCSR_ZE | MXCSR_DE | MXCSR_IE)
cpukit/score/cpu/i386/sse_test.c:190:#define FPSR_ALLE (FPSR_ES | FPSR_SF | FPSR_PE | FPSR_UE | FPSR_OE | FPSR_ZE | FPSR_DE | FPSR_IE)
cpukit/score/cpu/i386/sse_test.c:311:           fprintf(stderr,#fld" mismatch ("fmt" != "fmt")\n",a->fld, b->fld); \
cpukit/score/cpu/i386/sse_test.c:328:                fprintf(stderr,"fpreg[%u] TAG mismatch (%u != %u)\n",i,(a->ftw & (1<<i)) ? 1 : 0,(b->ftw & (1<<i)) ? 1 : 0); \
cpukit/score/cpu/i386/sse_test.c:552:			"ERROR: FPU CW initialization mismatch: got 0x%04"PRIx16"; expected 0x%04"PRIx16"\n",
cpukit/score/cpu/i386/sse_test.c:563:			"ERROR: MXCSR initialization mismatch: got 0x%08"PRIx32"; expected 0x%08"PRIx32"\n",
cpukit/score/cpu/i386/sse_test.c:660:	sc = rtems_task_start( hp_task, sse_test_hp_task, (rtems_task_argument)sse_test_sync );
cpukit/score/cpu/i386/sse_test.c:681:			fprintf(stderr,"sse_test ERROR: FPCW mismatch (after FP_EXC): expected 0x%04"PRIx16", got 0x%04"PRIx16"\n", fp_cw_set, fp_cw);
cpukit/score/cpu/i386/sse_test.c:685:			fprintf(stderr,"sse_test ERROR: MXCSR mismatch (after FP_EXC): expected 0x%08"PRIx32", got 0x%08"PRIx32"\n", mxcsr_set, mxcsr);
cpukit/score/cpu/i386/sse_test.c:701:			fprintf(stderr,"sse_test ERROR: FPCW mismatch (after SSE_EXC): expected 0x%04"PRIx16", got 0x%04"PRIx16"\n", fp_cw_set, fp_cw);
cpukit/score/cpu/i386/sse_test.c:705:			fprintf(stderr,"sse_test ERROR: MXCSR mismatch (after SSE_EXC): expected 0x%08"PRIx32", got 0x%08"PRIx32"\n", mxcsr_set, mxcsr);
cpukit/score/cpu/i386/sse_test.c:738:			fprintf(stderr,"sse_test ERROR: FPCW mismatch (after IRQ): expected 0x%04"PRIx16", got 0x%04"PRIx16"\n", fp_cw_set, fp_cw);
cpukit/score/cpu/i386/sse_test.c:742:			fprintf(stderr,"sse_test ERROR: MXCSR mismatch (after IRQ): expected 0x%08"PRIx32", got 0x%08"PRIx32"\n", mxcsr_set, mxcsr);
cpukit/score/cpu/i386/sse_test.c:751:	fprintf(stderr,"SSE/FPU Test %s (%u errors)\n", errs ? "FAILED":"PASSED", errs);
cpukit/score/cpu/i386/sse_test.c:863:	fprintf(stderr,"Resetting FP status 0x%02lx\n", p_ctxt->uc_mcontext.fpregs->sw);
cpukit/score/cpu/i386/rtems/score/idtr.h:48:extern void create_interrupt_gate_descriptor (interrupt_gate_descriptor*, rtems_raw_irq_hdl);
cpukit/score/cpu/i386/rtems/score/idtr.h:58: * C callable function enabling to change the value of IDT register. Must be called
cpukit/score/cpu/i386/rtems/score/cpu.h:311:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/i386/rtems/score/cpu.h:329: *  i386 is pretty tolerant of alignment.  Just put things on 4 byte boundaries.
cpukit/score/cpu/i386/rtems/score/cpu.h:418: * SP-> return_addr return here when _entry_point returns which (never happens)
cpukit/score/cpu/i386/rtems/score/cpu.h:443:    _stack -= 2*sizeof(proc_ptr*); /* see above for why we need to do this */ \
cpukit/score/cpu/i386/rtems/score/interrupts.h:27:typedef void (*rtems_raw_irq_enable)		(const struct __rtems_raw_irq_connect_data__*);
cpukit/score/cpu/i386/rtems/score/interrupts.h:28:typedef void (*rtems_raw_irq_disable)		(const struct __rtems_raw_irq_connect_data__*);
cpukit/score/cpu/i386/rtems/score/interrupts.h:29:typedef int  (*rtems_raw_irq_is_enabled)	(const struct __rtems_raw_irq_connect_data__*);
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:86:/* this bit is XSBSEN (xtended block size enable) on 7447, 7448, 7455 and 7457 only */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:89:#define HID0_BTIC	(1<<5)          /* Branch Target Instruction Cache [Enable] */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:257:#define	  L3CR_L3REP		  0x00001000 /* 19: L3 replacement algorithm (0=default, 1=alternate) */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:263:#define	   L3RT_PIPELINE_LATE	  0x00000100 /* Pipelined (register-register) synchronous late-write SRAM */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:265:#define	  L3CR_L3NIRCA		  0x00000080 /* 24: L3 non-integer ratios clock adjustment for the SRAM */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:268:#define	  L3CR_PMSIZ		  0x00000004 /* 31: Private memory size (0=1MB, 1=2MB) */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:401:#define PPC440_TLB0_EPN(n)       ( (((1<<22)-1)&(n)) << (31-21))  /* Etended Page Number    */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:402:#define PPC440_TLB0_EPN_GET(n)   (             ((n)  >> (31-21)) & ((1<<22)-1))
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:403:#define PPC440_TLB0_V            (               1   << (31-22))  /* Entry valid            */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:404:#define PPC440_TLB0_TS           (               1   << (31-23))  /* Translation space      */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:405:#define PPC440_TLB0_TSIZE(n)     (       (0xf & (n)) << (31-27))  /* Page size              */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:407:#define PPC440_TLB0_TPAR(n)      (       (0xf & (n)) << (31-31))  /* Tag Parity             */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:410:#define PPC440_PID_TID(n)        (      (0xff & (n)) << (31-31))  /* Translation ID         */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:413:#define PPC440_TLB1_RPN(n)       ( (((1<<22)-1)&(n)) << (31-21))  /* Real Page Number       */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:414:#define PPC440_TLB1_RPN_GET(n)   (             ((n)  >> (31-21)) & ((1<<22)-1))
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:415:#define PPC440_TLB1_PAR1(n)      (       (0x3 & (n)) << (31-23))  /* Parity for TLB word 1  */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:417:#define PPC440_TLB1_ERPN(n)      (       (0xf & (n)) << (31-31))  /* Extended Real Page No. */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:420:#define PPC440_TLB2_PAR2(n)      (       (0x3 & (n)) << (31- 1))  /* Parity for TLB word 2  */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:422:#define PPC440_TLB2_U0           (               1   << (31-16))  /* User attr. 0           */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:423:#define PPC440_TLB2_U1           (               1   << (31-17))  /* User attr. 1           */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:424:#define PPC440_TLB2_U2           (               1   << (31-18))  /* User attr. 2           */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:425:#define PPC440_TLB2_U3           (               1   << (31-19))  /* User attr. 3           */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:426:#define PPC440_TLB2_W            (               1   << (31-20))  /* Write-through          */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:427:#define PPC440_TLB2_I            (               1   << (31-21))  /* Cache-inhibited        */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:428:#define PPC440_TLB2_M            (               1   << (31-22))  /* Memory-coherence req.  */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:429:#define PPC440_TLB2_G            (               1   << (31-23))  /* Guarded                */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:430:#define PPC440_TLB2_E            (               1   << (31-24))  /* Little-endian          */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:431:#define PPC440_TLB2_UX           (               1   << (31-26))  /* User  exec.            */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:432:#define PPC440_TLB2_UW           (               1   << (31-27))  /* User  write            */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:433:#define PPC440_TLB2_UR           (               1   << (31-28))  /* User  read             */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:434:#define PPC440_TLB2_SX           (               1   << (31-29))  /* Super exec.            */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:435:#define PPC440_TLB2_SW           (               1   << (31-30))  /* Super write            */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:436:#define PPC440_TLB2_SR           (               1   << (31-31))  /* Super read             */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:458:/* Freescale Book E Implementation Standards (EIS): Hardware Implementation-Dependent Registers */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:558:/* Freescale Book E Implementation Standards (EIS): Signal Processing Engine (SPE) */
cpukit/score/cpu/powerpc/rtems/powerpc/registers.h:594:    __asm__ volatile ("mfmsr %0" : "=&r" ((_msr_value)) : "0" ((_msr_value))); \
cpukit/score/cpu/powerpc/rtems/score/cpu.h:518:/* conservative setting (FALSE); probably doesn't affect performance too much */
cpukit/score/cpu/powerpc/rtems/score/powerpc.h:122:#if defined(_SOFT_FLOAT) || defined(__NO_FPRS__) /* e500 has unified integer/FP registers */
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:666:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:720: *         On byte oriented architectures, @ref CPU_HEAP_ALIGNMENT normally will
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:721: *         have to be greater or equal to than @ref CPU_ALIGNMENT to ensure that
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:755: *  @note This must be a power of 2 either 0 or greater than @ref CPU_ALIGNMENT.
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:769: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:811: *  This temporarily restores the interrupt to @a _isr_cookie before immediately
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:953: *    -# putting a "null FP status word" in the correct place in the FP context.
cpukit/score/cpu/no_cpu/rtems/score/cpu.h:1269: *  The CPU exception frame may be available in fatal error conditions like for
cpukit/score/cpu/no_cpu/rtems/asm.h:86:/** This macro is used to denote the beginning of a data declaration section. */
cpukit/score/cpu/m68k/rtems/score/cpu.h:231:         * We need to save the FP Instruction Address Register (FPIAR), because
cpukit/score/cpu/m68k/rtems/score/cpu.h:246:     * registers is zero.  The reset value of the FP data register is NAN.  The
cpukit/score/cpu/m68k/rtems/score/cpu.h:254:     *  FP context save area for the M68881/M68882 and 68060 numeric coprocessors.
cpukit/score/cpu/m68k/rtems/score/cpu.h:363:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/m68k/rtems/score/cpu.h:386: *  m68k is pretty tolerant of alignment.  Just put things on 4 byte boundaries.
cpukit/score/cpu/m68k/rtems/score/m68k.h:309:# error "Unsupported 68000 CPU model -- are you sure you're running a 68k compiler?"
cpukit/score/cpu/m68k/rtems/score/m68k.h:412:#define m68k_set_cacr(_cacr) __asm__ volatile ("movec %0,%%cacr" : : "d" (_cacr))
cpukit/score/cpu/m68k/rtems/score/m68k.h:413:#define m68k_set_acr0(_acr0) __asm__ volatile ("movec %0,%%acr0" : : "d" (_acr0))
cpukit/score/cpu/m68k/rtems/score/m68k.h:414:#define m68k_set_acr1(_acr1) __asm__ volatile ("movec %0,%%acr1" : : "d" (_acr1))
cpukit/score/cpu/m68k/rtems/m68k/sim.h:236: * CSPARx Field    |Chip Select Signal  |  Alternate Signal  |  Discrete Output
cpukit/score/cpu/m68k/rtems/m68k/sim.h:237: *-----------------+--------------------+--------------------+---------------*/
cpukit/score/cpu/m68k/rtems/m68k/sim.h:238:#define CS_5    12 /*     !CS5          |         FC2        |       PC2     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:239:#define CS_4    10 /*     !CS4          |         FC1        |       PC1     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:240:#define CS_3     8 /*     !CS3          |         FC0        |       PC0     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:241:#define CS_2     6 /*     !CS2          |       !BGACK       |               */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:242:#define CS_1     4 /*     !CS1          |         !BG        |               */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:243:#define CS_0     2 /*     !CS0          |         !BR        |               */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:244:#define CSBOOT   0 /*     !CSBOOT       |                    |               */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:245:/*                 |                    |                    |               */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:246:#define CS_10    8 /*     !CS10         |       ADDR23       |      ECLK     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:247:#define CS_9     6 /*     !CS9          |       ADDR22       |       PC6     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:248:#define CS_8     4 /*     !CS8          |       ADDR21       |       PC5     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:249:#define CS_7     2 /*     !CS7          |       ADDR20       |       PC4     */
cpukit/score/cpu/m68k/rtems/m68k/sim.h:250:#define CS_6     0 /*     !CS6          |       ADDR19       |       PC3     */
cpukit/score/cpu/m68k/rtems/m68k/m68302.h:640:          __REG_CAT(m302.reg.or, csel) = MAKE_OR(bsize, DtAck, RW_Mask, FC_Mask)
cpukit/score/cpu/m68k/rtems/m68k/m68302.h:647:#define WATCHDOG_TRIGGER() (m302.reg.wrr = 0x10 | WATCHDOG_ENABLE, m302.reg.wcn = 0)
cpukit/score/cpu/arm/cpu.c:70:    "bic %[arm_switch_reg], #" _CPU_ISR_LEVEL_STRINGOF( CPU_MODES_INTERRUPT_MASK ) "\n"
cpukit/score/cpu/arm/arm_exc_handler_high.c:75:        printk("*********** FAULTY THREAD WILL BE DELETED **************\n\r");
cpukit/score/cpu/arm/rtems/score/cpu.h:52:  #define ARM_SWITCH_BACK "add %[arm_switch_reg], pc, #1\nbx %[arm_switch_reg]\n.thumb\n"
cpukit/score/cpu/arm/rtems/score/cpu.h:174: * operating system support for a FIQ, she can trigger a software interrupt and
cpukit/score/cpu/arm/rtems/score/cpu.h:185:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/arm/rtems/score/cpu.h:423:  void _ARMV7M_Start_multitasking( Context_Control *bsp, Context_Control *heir );
cpukit/score/cpu/m32r/rtems/score/cpu.h:605:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/m32r/rtems/score/cpu.h:652: *         On byte oriented architectures, @ref CPU_HEAP_ALIGNMENT normally will
cpukit/score/cpu/m32r/rtems/score/cpu.h:653: *         have to be greater or equal to than @ref CPU_ALIGNMENT to ensure that
cpukit/score/cpu/m32r/rtems/score/cpu.h:687: *  @note This must be a power of 2 either 0 or greater than @ref CPU_ALIGNMENT.
cpukit/score/cpu/m32r/rtems/score/cpu.h:701: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/m32r/rtems/score/cpu.h:744: *  This temporarily restores the interrupt to @a _isr_cookie before immediately
cpukit/score/cpu/m32r/rtems/score/cpu.h:892: *    -# putting a "null FP status word" in the correct place in the FP context.
cpukit/score/cpu/m32r/rtems/asm.h:86:/** This macro is used to denote the beginning of a data declaration section. */
cpukit/score/cpu/v850/cpu.c:38: *  This method returns 0 if interrupts are enabled and 1 if they are disabled.
cpukit/score/cpu/v850/rtems/score/cpu.h:564:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/v850/rtems/score/cpu.h:611: *         On byte oriented architectures, @ref CPU_HEAP_ALIGNMENT normally will
cpukit/score/cpu/v850/rtems/score/cpu.h:612: *         have to be greater or equal to than @ref CPU_ALIGNMENT to ensure that
cpukit/score/cpu/v850/rtems/score/cpu.h:646: *  @note This must be a power of 2 either 0 or greater than @ref CPU_ALIGNMENT.
cpukit/score/cpu/v850/rtems/score/cpu.h:700: *  This temporarily restores the interrupt to @a _isr_cookie before immediately
cpukit/score/cpu/v850/rtems/score/cpu.h:709: *  This saves at least one instruction over using enable/disable back to back.
cpukit/score/cpu/v850/rtems/score/cpu.h:858: *    -# putting a "null FP status word" in the correct place in the FP context.
cpukit/score/cpu/v850/rtems/asm.h:88:/** This macro is used to denote the beginning of a data declaration section. */
cpukit/score/cpu/bfin/cpu.c:69:    _CPU_ISR_install_raw_handler(i, _CPU_Unhandled_Interrupt_handler, &ignored);
cpukit/score/cpu/bfin/rtems/score/cpu.h:598:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/bfin/rtems/score/cpu.h:645: *         On byte oriented architectures, @ref CPU_HEAP_ALIGNMENT normally will
cpukit/score/cpu/bfin/rtems/score/cpu.h:646: *         have to be greater or equal to than @ref CPU_ALIGNMENT to ensure that
cpukit/score/cpu/bfin/rtems/score/cpu.h:680: *  @note This must be a power of 2 either 0 or greater than @ref CPU_ALIGNMENT.
cpukit/score/cpu/bfin/rtems/score/cpu.h:694: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/bfin/rtems/score/cpu.h:737: *  This temporarily restores the interrupt to @a _isr_cookie before immediately
cpukit/score/cpu/bfin/rtems/score/cpu.h:772:    __asm__ __volatile__ ( "sti %0; csync" : : "d"(_new_level ? 0 : 0xffff) ); \
cpukit/score/cpu/bfin/rtems/score/cpu.h:887: *    -# putting a "null FP status word" in the correct place in the FP context.
cpukit/score/cpu/bfin/rtems/asm.h:86:/** This macro is used to denote the beginning of a data declaration section. */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:364:#define CPLB_VALID_P            0x00000000  /* 0=invalid entry, 1=valid entry */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:365:#define CPLB_LOCK_P             0x00000001  /* 0=entry may be replaced, 1=entry locked */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:366:#define CPLB_USER_RD_P          0x00000002  /* 0=no read access, 1=read access allowed (user mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:368:#define CPLB_VALID             0x00000001  /* 0=invalid entry, 1=valid entry */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:369:#define CPLB_LOCK              0x00000002  /* 0=entry may be replaced, 1=entry locked */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:370:#define CPLB_USER_RD           0x00000004  /* 0=no read access, 1=read access allowed (user mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:375:#define CPLB_PORTPRIO             0x00000200  /* 0=low priority port, 1= high priority port */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:376:#define CPLB_L1_CHBL           0x00001000  /* 0=non-cacheable in L1, 1=cacheable in L1 */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:378:#define CPLB_LRUPRIO              0x00000100  /* 0=can be replaced by any line, 1=priority for non-replacement */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:380:#define CPLB_USER_WR           0x00000008  /* 0=no write access, 0=write access allowed (user mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:381:#define CPLB_SUPV_WR           0x00000010  /* 0=no write access, 0=write access allowed (supervisor mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:383:#define CPLB_L1_AOW                       0x00008000  /* 0=do not allocate cache lines on write-through writes,  */
cpukit/score/cpu/bfin/rtems/bfin/bf533.h:384:                                                                                  /* 1= allocate cache lines on write-through writes. */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:401:#define CPLB_VALID_P            0x00000000  /* 0=invalid entry, 1=valid entry */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:402:#define CPLB_LOCK_P             0x00000001  /* 0=entry may be replaced, 1=entry locked */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:403:#define CPLB_USER_RD_P          0x00000002  /* 0=no read access, 1=read access allowed (user mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:405:#define CPLB_VALID             0x00000001  /* 0=invalid entry, 1=valid entry */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:406:#define CPLB_LOCK              0x00000002  /* 0=entry may be replaced, 1=entry locked */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:407:#define CPLB_USER_RD           0x00000004  /* 0=no read access, 1=read access allowed (user mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:412:#define CPLB_PORTPRIO             0x00000200  /* 0=low priority port, 1= high priority port */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:413:#define CPLB_L1_CHBL           0x00001000  /* 0=non-cacheable in L1, 1=cacheable in L1 */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:415:#define CPLB_LRUPRIO              0x00000100  /* 0=can be replaced by any line, 1=priority for non-replacement */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:417:#define CPLB_USER_WR           0x00000008  /* 0=no write access, 0=write access allowed (user mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:418:#define CPLB_SUPV_WR           0x00000010  /* 0=no write access, 0=write access allowed (supervisor mode) */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:420:#define CPLB_L1_AOW                       0x00008000  /* 0=do not allocate cache lines on write-through writes,  */
cpukit/score/cpu/bfin/rtems/bfin/bf52x.h:421:                                                                                  /* 1= allocate cache lines on write-through writes. */
cpukit/score/cpu/sh/cpu.c:161:  _CPU_ISR_install_raw_handler(vector, _Hardware_isr_Table[vector], &ignored );
cpukit/score/cpu/sh/rtems/score/cpu.h:440:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER  (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/sh/rtems/score/cpu.h:516: *  Support routine to initialize the RTEMS vector table after it is allocated.
cpukit/score/cpu/sh/rtems/score/sh.h:242:                                         dividend (and quotient) is negative */
cpukit/score/cpu/nios2/nios2-mpu-descriptor.c:102:      | ((desc->index << NIOS2_MPUBASE_INDEX_OFFSET) & NIOS2_MPUBASE_INDEX_MASK)
cpukit/score/cpu/nios2/nios2-mpu-descriptor.c:136:    desc->perm = (mpuacc & NIOS2_MPUACC_PERM_MASK) >> NIOS2_MPUACC_PERM_OFFSET;
cpukit/score/cpu/nios2/nios2-initialize-vectors.c:24:  memset(_ISR_Vector_table, 0, sizeof(ISR_Handler_entry) * ISR_NUMBER_OF_VECTORS);
cpukit/score/cpu/nios2/nios2-context-initialize.c:47:      .base = (void *) ((int) stack_area_begin & ~((1 << mpu_config->data_region_size_log2) - 1)),
cpukit/score/cpu/nios2/rtems/score/cpu.h:40:#define CPU_INTERRUPT_MAXIMUM_VECTOR_NUMBER (CPU_INTERRUPT_NUMBER_OF_VECTORS - 1)
cpukit/score/cpu/nios2/rtems/score/cpu.h:66:#define CPU_STRUCTURE_ALIGNMENT __attribute__((section(".sdata"), aligned(32)))
cpukit/score/cpu/nios2/rtems/score/cpu.h:95: * A Nios II configuration with an external interrupt controller (EIC) supports
cpukit/score/cpu/nios2/rtems/score/cpu.h:98: * disabled).  The _CPU_ISR_Get_level() and _CPU_ISR_Set_level() functions will
cpukit/score/cpu/nios2/rtems/score/cpu.h:256: * not flush the pipeline and has only a late result penalty.  The wrctl on the
cpukit/score/cpu/nios2/rtems/score/nios2-utility.h:153: * @brief This global symbol specifies the status register mask used to disable
cpukit/score/inline/rtems/score/tqdata.inl:18:# error "Never use <rtems/score/tqdata.inl> directly; include <rtems/score/tqdata.h> instead."
cpukit/score/inline/rtems/score/tod.inl:4: *  This file contains the static inline implementation of the inlined routines
cpukit/score/inline/rtems/score/tod.inl:18:# error "Never use <rtems/score/tod.inl> directly; include <rtems/score/tod.h> instead."
cpukit/score/inline/rtems/score/tod.inl:52: *  This routine returns a timeval based upon the internal timespec format TOD.
cpukit/score/inline/rtems/score/mppkt.inl:18:# error "Never use <rtems/score/mppkt.inl> directly; include <rtems/score/mppkt.h> instead."
cpukit/score/inline/rtems/score/chain.inl:21:# error "Never use <rtems/score/chain.inl> directly; include <rtems/score/chain.h> instead."
cpukit/score/inline/rtems/score/chain.inl:604: * @brief Prepend a node and check if the chain was empty before (unprotected).
cpukit/score/inline/rtems/score/objectmp.inl:18:# error "Never use <rtems/score/objectmp.inl> directly; include <rtems/score/objectmp.h> instead."
cpukit/score/inline/rtems/score/coresem.inl:18:# error "Never use <rtems/score/coresem.inl> directly; include <rtems/score/coresem.h> instead."
cpukit/score/inline/rtems/score/coresem.inl:43:   return ( the_attribute->discipline == CORE_SEMAPHORE_DISCIPLINES_PRIORITY );
cpukit/score/inline/rtems/score/states.inl:18:# error "Never use <rtems/score/states.inl> directly; include <rtems/score/states.h> instead."
cpukit/score/inline/rtems/score/isr.inl:18:# error "Never use <rtems/score/isr.inl> directly; include <rtems/score/isr.h> instead."
cpukit/score/inline/rtems/score/corespinlock.inl:18:# error "Never use <rtems/score/corespinlock.inl> directly; include <rtems/score/corespinlock.h> instead."
cpukit/score/inline/rtems/score/scheduler.inl:18:# error "Never use <rtems/score/scheduler.inl> directly; include <rtems/score/scheduler.h> instead."
cpukit/score/inline/rtems/score/thread.inl:18:# error "Never use <rtems/score/thread.inl> directly; include <rtems/score/thread.h> instead."
cpukit/score/inline/rtems/score/thread.inl:67:  RTEMS_INLINE_ROUTINE uint32_t _Thread_Dispatch_set_disable_level(uint32_t value)
cpukit/score/inline/rtems/score/thread.inl:324:  return (Thread_Control *) _Objects_Allocate( &_Thread_Internal_information );
cpukit/score/inline/rtems/score/object.inl:18:# error "Never use <rtems/score/object.inl> directly; include <rtems/score/object.h> instead."
cpukit/score/inline/rtems/score/object.inl:62:  return (Objects_APIs) ((id >> OBJECTS_API_START_BIT) & OBJECTS_API_VALID_BITS);
cpukit/score/inline/rtems/score/stack.inl:18:# error "Never use <rtems/score/stack.inl> directly; include <rtems/score/stack.h> instead."
cpukit/score/inline/rtems/score/coremsg.inl:18:# error "Never use <rtems/score/coremsg.inl> directly; include <rtems/score/coremsg.h> instead."
cpukit/score/inline/rtems/score/coremsg.inl:208: *  This function returns true if the_message_queue is true and false otherwise.
cpukit/score/inline/rtems/score/corebarrier.inl:18:# error "Never use <rtems/score/corebarrier.inl> directly; include <rtems/score/corebarrier.h> instead."
cpukit/score/inline/rtems/score/corebarrier.inl:48: *  This routine returns the number of threads currently waiting at the barrier.
cpukit/score/inline/rtems/score/sysstate.inl:19:# error "Never use <rtems/score/sysstate.inl> directly; include <rtems/score/sysstate.h> instead."
cpukit/score/inline/rtems/score/corerwlock.inl:18:# error "Never use <rtems/score/corerwlock.inl> directly; include <rtems/score/corerwlock.h> instead."
cpukit/score/inline/rtems/score/prioritybitmap.inl:18:# error "Never use <rtems/score/prioritybitmap.inl> directly; include <rtems/score/prioritybitmap.h> instead."
cpukit/score/inline/rtems/score/prioritybitmap.inl:179:  /* Add _Priority_Mask_invert to non-generic bitfield then change this code. */
cpukit/score/inline/rtems/score/prioritybitmap.inl:180:  the_priority_map->block_major = (Priority_bit_map_Control)(~((uint32_t)mask));
cpukit/score/inline/rtems/score/prioritybitmap.inl:184:  /* Add _Priority_Mask_invert to non-generic bitfield then change this code. */
cpukit/score/inline/rtems/score/prioritybitmap.inl:185:  the_priority_map->block_minor = (Priority_bit_map_Control)(~((uint32_t)mask));
cpukit/score/inline/rtems/score/rbtree.inl:21:# error "Never use <rtems/score/rbtree.inl> directly; include <rtems/score/rbtree.h> instead."
cpukit/score/inline/rtems/score/rbtree.inl:64:  return (node->parent == NULL) && (node->child[RBT_LEFT] == NULL) && (node->child[RBT_RIGHT] == NULL);
cpukit/score/inline/rtems/score/rbtree.inl:225:  return (the_rbtree->root->child[RBT_LEFT] == NULL && the_rbtree->root->child[RBT_RIGHT] == NULL);
cpukit/score/inline/rtems/score/threadmp.inl:18:# error "Never use <rtems/score/threadmp.inl> directly; include <rtems/score/threadmp.h> instead."
cpukit/score/inline/rtems/score/schedulerpriority.inl:18:# error "Never use <rtems/score/schedulerpriority.inl> directly; include <rtems/score/schedulerpriority.h> instead."
cpukit/score/inline/rtems/score/schedulersimple.inl:17:# error "Never use <rtems/score/schedulersimple.inl> directly; include <rtems/score/schedulersimple.h> instead."
cpukit/score/inline/rtems/score/watchdog.inl:18:# error "Never use <rtems/score/watchdog.inl> directly; include <rtems/score/watchdog.h> instead."
cpukit/score/inline/rtems/score/coremutex.inl:18:# error "Never use <rtems/score/coremutex.inl> directly; include <rtems/score/coremutex.h> instead."
cpukit/score/inline/rtems/score/coremutex.inl:54: *  @return This method returns true if the mutex is using FIFO blocking order.
cpukit/score/inline/rtems/score/priority.inl:18:# error "Never use <rtems/score/priority.inl> directly; include <rtems/score/priority.h> instead."
cpukit/score/inline/rtems/score/address.inl:18:# error "Never use <rtems/score/address.inl> directly; include <rtems/score/address.h> instead."
cpukit/score/inline/rtems/score/heap.inl:19:# error "Never use <rtems/score/heap.inl> directly; include <rtems/score/heap.h> instead."
cpukit/score/inline/rtems/score/heap.inl:204: * block appears as used for the _Heap_Is_used() and _Heap_Is_free() functions.
cpukit/score/inline/rtems/score/wkspace.inl:18:# error "Never use <rtems/score/wkspace.inl> directly; include <rtems/score/wkspace.h> instead."
cpukit/score/inline/rtems/score/threadq.inl:18:# error "Never use <rtems/score/threadq.inl> directly; include <rtems/score/threadq.h> instead."
cpukit/libmisc/stackchk/check.c:92:   * We need this magic offset because during a task delete the task stack will
cpukit/libmisc/stackchk/check.c:93:   * be freed before we enter the task switch extension which checks the stack.
cpukit/libmisc/stackchk/check.c:203:  the_pattern = Stack_check_Get_pattern_area(&the_thread->Start.Initial_stack);
cpukit/libmisc/stackchk/check.c:247:      "damaged pattern area (%lu Bytes): 0x%08" PRIxPTR " .. 0x%08" PRIxPTR "\n",
cpukit/libmisc/capture/capture-cli.c:66:                        const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:67:                        bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:95:        fprintf (stdout, "error: size must be greater than or equal to 100\n");
cpukit/libmisc/capture/capture-cli.c:118:    fprintf (stdout, "error: open enable failed: %s\n", rtems_status_text (sc));
cpukit/libmisc/capture/capture-cli.c:135:rtems_capture_cli_close (int                          argc __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:136:                         char**                       argv __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:137:                         const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:138:                         bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:163:rtems_capture_cli_enable (int                          argc __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:164:                          char**                       argv __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:165:                          const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:166:                          bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:191:rtems_capture_cli_disable (int                          argc __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:192:                           char**                       argv __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:193:                           const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:194:                           bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:219:rtems_capture_cli_task_list (int                          argc __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:220:                             char**                       argv __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:221:                             const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:222:                             bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:278:             rtems_capture_task_flags (task) & RTEMS_CAPTURE_TRACED ? 't' : '-');
cpukit/libmisc/capture/capture-cli.c:307:rtems_capture_cli_task_load_thread (rtems_task_argument arg __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:372:             "     PID NAME RPRI CPRI STATE  %%CPU     %%STK FLGS    EXEC TIME\n");
cpukit/libmisc/capture/capture-cli.c:409:      rtems_monitor_dump_priority (rtems_capture_task_curr_priority (tasks[i]));
cpukit/libmisc/capture/capture-cli.c:416:              rtems_capture_task_flags (tasks[i]) & RTEMS_CAPTURE_TRACED ? 't' : '-');
cpukit/libmisc/capture/capture-cli.c:458:rtems_capture_cli_task_load (int                          argc __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:459:                             char**                       argv __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:460:                             const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:461:                             bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:468:  sc = rtems_task_set_priority (RTEMS_SELF, RTEMS_CURRENT_PRIORITY, &priority);
cpukit/libmisc/capture/capture-cli.c:531:rtems_capture_cli_watch_list (int                          argc __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:532:                              char**                       argv __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:533:                              const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:534:                              bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:685:                             const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:686:                             bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:748:                             const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:749:                             bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:805:static char const * watch_control_usage = "usage: cwctl [task name] [id] on/off\n";
cpukit/libmisc/capture/capture-cli.c:810:                                 const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:811:                                 bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:877:                                const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:878:                                bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:931:                                 const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:932:                                 bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:982:                               const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:983:                               bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:1074:  (sizeof (rtems_capture_cli_triggers) / sizeof (rtems_capture_cli_triggers_t))
cpukit/libmisc/capture/capture-cli.c:1236:                                      rtems_capture_cli_triggers[trigger].type);
cpukit/libmisc/capture/capture-cli.c:1260:                               const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:1261:                               bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:1278:                                 const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:1279:                                 bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:1296:                                 const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:1297:                                 bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:1343:      fprintf (stdout, "error: trace read failed: %s\n", rtems_status_text (sc));
cpukit/libmisc/capture/capture-cli.c:1427:                         const rtems_monitor_command_arg_t* command_arg __attribute__((unused)),
cpukit/libmisc/capture/capture-cli.c:1428:                         bool                         verbose __attribute__((unused)))
cpukit/libmisc/capture/capture-cli.c:1615:       cmd < sizeof (rtems_capture_cli_cmds) / sizeof (rtems_monitor_command_entry_t);
cpukit/libmisc/capture/capture.c:991:rtems_capture_open (uint32_t   size, rtems_capture_timestamp timestamp __attribute__((unused)))
cpukit/libmisc/capture/capture.c:1869:  if ((event < RTEMS_CAPTURE_EVENT_START) || (event > RTEMS_CAPTURE_EVENT_END))
cpukit/libmisc/shell/shell_script.c:124:  while ( (option = getopt_r( argc, argv, "o:p:s:t:v", &getopt_reent)) != -1 ) {
cpukit/libmisc/shell/shell-wait-for-input.c:32:    new_term.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL | IXON);
cpukit/libmisc/shell/shell.c:657:  int                cmd_count = 1; /* assume a script and so only 1 command line */
cpukit/libmisc/shell/shell.c:744:                "shell:cannot set terminal attributes(%s)\n",shell_env->devname);
cpukit/libmisc/shell/main_mknod.c:382:callPack(rtems_shell_mknod_globals* globals, pack_t *f, int n, u_long *numbers)
cpukit/libmisc/shell/fdisk.c:165:              RTEMS_BDPART_SHELL_ERROR( "type value out of range: %s", argv [ai]);
cpukit/libmisc/shell/fdisk.c:225:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot create partitions for '%s'", disk_name);
cpukit/libmisc/shell/fdisk.c:231:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot write partitions to '%s'", disk_name);
cpukit/libmisc/shell/fdisk.c:238:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot read partitions from '%s'", disk_name);
cpukit/libmisc/shell/fdisk.c:244:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot register partitions of '%s'", disk_name);
cpukit/libmisc/shell/fdisk.c:250:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot unregister partitions of '%s'", disk_name);
cpukit/libmisc/shell/fdisk.c:256:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot mount partitions of '%s' to '%s'", disk_name, mount_base);
cpukit/libmisc/shell/fdisk.c:262:    RTEMS_BDPART_SHELL_ERROR_SC( sc, "cannot unmount partitions of '%s'", disk_name);
cpukit/libmisc/shell/main_blksync.c:55:    fprintf( stderr, "%s: driver open failed: %s\n", argv[0], strerror (errno));
cpukit/libmisc/shell/main_blksync.c:60:    fprintf( stderr, "%s: driver sync failed: %s\n", argv[0], strerror (errno));
cpukit/libmisc/shell/main_msdosfmt.c:146:    printf (" %-20s: %" PRIu32 "\n", "sectors per cluster", rqdata.sectors_per_cluster);
cpukit/libmisc/shell/main_msdosfmt.c:148:    printf (" %-20s: %" PRIu32 "\n", "files per root dir", rqdata.files_per_root_dir);
cpukit/libmisc/shell/main_msdosfmt.c:165:#define OPTIONS "[-V label] [-s sectors/cluster] [-r size] [-t any/12/16/32] [-v]"
cpukit/libmisc/shell/main_cpuuse.c:32:    rtems_cpu_usage_report_with_plugin(stdout, (rtems_printk_plugin_t)fprintf);
cpukit/libmisc/shell/main_netstats.c:58:  while ( (option = getopt_r( argc, argv, "Aimfpcutv", &getopt_reent)) != -1 ) {
cpukit/libmisc/shell/main_help.c:117:        printf("help: topic or cmd '%s' not found. Try <help> alone for a list\n",
cpukit/libmisc/shell/cmds.c:48:static bool rtems_shell_register_command(const rtems_monitor_command_entry_t *e, void *arg __attribute__((unused)))
cpukit/libmisc/monitor/mon-extension.c:20:    const Extension_Control *rtems_extension = (const Extension_Control *) extension_void;
cpukit/libmisc/monitor/mon-extension.c:49:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-extension.c:50:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-extension.c:74:    length += rtems_monitor_symbol_dump(&monitor_extension->e_create, verbose);
cpukit/libmisc/monitor/mon-extension.c:78:    length += rtems_monitor_symbol_dump(&monitor_extension->e_restart, verbose);
cpukit/libmisc/monitor/mon-extension.c:84:    length += rtems_monitor_symbol_dump(&monitor_extension->e_delete, verbose);
cpukit/libmisc/monitor/mon-extension.c:86:    length += rtems_monitor_symbol_dump(&monitor_extension->e_tswitch, verbose);
cpukit/libmisc/monitor/mon-extension.c:94:    length += rtems_monitor_symbol_dump(&monitor_extension->e_exitted, verbose);
cpukit/libmisc/monitor/mon-prmisc.c:24:    fprintf(stdout,"------------------------------------------------------------------------------\n");
cpukit/libmisc/monitor/mon-symbols.c:87:            newsize = table->size + (table->size / (100 / table->growth_factor));
cpukit/libmisc/monitor/mon-symbols.c:89:        table->addresses = (rtems_symbol_t *) realloc((void *) table->addresses, newsize * sizeof(rtems_symbol_t));
cpukit/libmisc/monitor/mon-symbols.c:106:        p = (rtems_symbol_string_block_t *) malloc(sizeof(rtems_symbol_string_block_t));
cpukit/libmisc/monitor/mon-symbols.c:340:    strncpy(canonical_symbol->name, sp->name, sizeof(canonical_symbol->name)-1);
cpukit/libmisc/monitor/mon-symbols.c:374:        strncpy(canonical_symbol->name, sp->name, sizeof(canonical_symbol->name)-1);
cpukit/libmisc/monitor/mon-symbols.c:483:            rtems_monitor_symbol_canonical_by_name(&canonical_symbol, argv[arg]);
cpukit/libmisc/monitor/mon-mpci.c:102:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-mpci.c:103:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-mpci.c:123:    length += rtems_monitor_dump_decimal(monitor_mpci->maximum_global_objects);
cpukit/libmisc/monitor/mon-mpci.c:132:    length += rtems_monitor_dump_decimal((uint32_t) monitor_mpci->maximum_packet_size);
cpukit/libmisc/monitor/mon-mpci.c:139:    length += rtems_monitor_symbol_dump(&monitor_mpci->initialization, verbose);
cpukit/libmisc/monitor/mon-mpci.c:148:    length += rtems_monitor_symbol_dump(&monitor_mpci->return_packet, verbose);
cpukit/libmisc/monitor/mon-mpci.c:157:    length += rtems_monitor_symbol_dump(&monitor_mpci->receive_packet, verbose);
cpukit/libmisc/monitor/mon-task.c:46:    canonical_task->modes = 0; /* XXX FIX ME.... rtems_thread->current_modes; */
cpukit/libmisc/monitor/mon-task.c:47:    canonical_task->attributes = 0 /* XXX FIX ME rtems_thread->API_Extensions[ THREAD_API_RTEMS ]->attribute_set */;
cpukit/libmisc/monitor/mon-task.c:48:    (void) memcpy(canonical_task->notepad, api ->Notepads, sizeof(canonical_task->notepad));
cpukit/libmisc/monitor/mon-task.c:51:    (void) memcpy(&canonical_task->wait_args, &rtems_thread->Wait.Extra, sizeof(canonical_task->wait_args));
cpukit/libmisc/monitor/mon-task.c:62:  ID       NAME           PRI  STATE MODES   EVENTS    WAITID  WAITARG  NOTES\n\
cpukit/libmisc/monitor/mon-task.c:64:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-task.c:65:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-itask.c:28:                                            (void *) rtems_itask->entry_point);
cpukit/libmisc/monitor/mon-itask.c:76:  #    NAME   ENTRY        ARGUMENT    PRIO   MODES  ATTRIBUTES   STACK SIZE\n");
cpukit/libmisc/monitor/mon-itask.c:77:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-itask.c:78:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-part.c:21:    const Partition_Control *rtems_part = (const Partition_Control *) part_void;
cpukit/libmisc/monitor/mon-sema.c:21:    const Semaphore_Control *rtems_sema = (const Semaphore_Control *) sema_void;
cpukit/libmisc/monitor/mon-driver.c:43:    const rtems_driver_address_table *d = (const rtems_driver_address_table *) driver_void;
cpukit/libmisc/monitor/mon-driver.c:99:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-driver.c:100:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-driver.c:119:    length += rtems_monitor_symbol_dump(&monitor_driver->initialization, verbose);
cpukit/libmisc/monitor/mon-config.c:49:    canonical_config->number_of_initialization_tasks = r->number_of_initialization_tasks;
cpukit/libmisc/monitor/mon-config.c:88:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-config.c:89:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-config.c:112:    length += fprintf(stdout,"usec/tick: %" PRId32 ";  tick/timeslice: %" PRId32 ";  tick/sec: %" PRId32 "\n",
cpukit/libmisc/monitor/mon-config.c:120:    length += fprintf(stdout,"tasks: %" PRId32 ";  timers: %" PRId32 ";  sems: %" PRId32 ";  que's: %" PRId32 ";  ext's: %" PRId32 "\n",
cpukit/libmisc/monitor/mon-config.c:128:    length += fprintf(stdout,"partitions: %" PRId32 ";  regions: %" PRId32 ";  ports: %" PRId32 ";  periods: %" PRId32 "\n",
cpukit/libmisc/monitor/mon-queue.c:16:    const Message_queue_Control *rtems_queue = (const Message_queue_Control *) queue_void;
cpukit/libmisc/monitor/mon-queue.c:19:    canonical_queue->maximum_message_size = rtems_queue->message_queue.maximum_message_size;
cpukit/libmisc/monitor/mon-queue.c:20:    canonical_queue->maximum_pending_messages = rtems_queue->message_queue.maximum_pending_messages;
cpukit/libmisc/monitor/mon-queue.c:21:    canonical_queue->number_of_pending_messages = rtems_queue->message_queue.number_of_pending_messages;
cpukit/libmisc/monitor/mon-queue.c:31:/*23456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789
cpukit/libmisc/monitor/mon-queue.c:32:0         1         2         3         4         5         6         7       */
cpukit/libmisc/monitor/mon-queue.c:57:    length += rtems_monitor_dump_decimal(monitor_queue->number_of_pending_messages);
cpukit/libmisc/monitor/mon-queue.c:59:    length += rtems_monitor_dump_decimal(monitor_queue->maximum_pending_messages);
cpukit/libmisc/monitor/mon-monitor.c:146:      "  Default is to display information about all semaphores on this node\n"
cpukit/libmisc/monitor/mon-monitor.c:166:      "  Default is to display information about all partitions on this node\n"
cpukit/libmisc/monitor/mon-monitor.c:265:static const rtems_monitor_command_entry_t *rtems_monitor_registered_commands =
cpukit/libmisc/monitor/mon-object.c:69:      (rtems_monitor_object_dump_header_fn) rtems_monitor_init_task_dump_header,
cpukit/libmisc/monitor/mon-object.c:117:      (rtems_monitor_object_dump_header_fn) rtems_monitor_extension_dump_header,
cpukit/libmisc/monitor/mon-object.c:339:    next_id = RTEMS_OBJECT_ID_INITIAL(OBJECTS_CLASSIC_API, info->type, rtems_monitor_default_node);
cpukit/libmisc/monitor/mon-object.c:344:                                         &canonical)) != RTEMS_OBJECT_ID_FINAL)
cpukit/libmisc/monitor/mon-object.c:391:            type = (rtems_monitor_object_type_t) rtems_object_id_get_class(id);
cpukit/libmisc/monitor/mon-server.c:79:        status = rtems_message_queue_receive(rtems_monitor_server_response_queue_id,
cpukit/libmisc/monitor/mon-server.c:154:                                                             &response.payload,
cpukit/libmisc/monitor/mon-server.c:177:                rtems_error(0, "invalid command to monitor server: %d", request.command);
cpukit/libmisc/monitor/mon-server.c:242:            rtems_error(status, "could not create monitor server message queue");
cpukit/libmisc/monitor/mon-server.c:261:            rtems_error(status, "could not create monitor response message queue");
cpukit/libmisc/monitor/mon-server.c:268:                   (rtems_id *) malloc((maximum_nodes + 1) * sizeof(rtems_id));
cpukit/libmisc/monitor/mon-network.c:115:            if (inet_pton(AF_INET, argv[cur_idx+1], &broadcast.sin_addr) < 0) {
cpukit/libmisc/monitor/mon-network.c:202:            printf("Could not set destination address: %s\n", strerror(errno));
cpukit/libmisc/monitor/monitor.h:58:#define RTEMS_MONITOR_WAITQUIT  0x0010 /* wait for monitor task to terminate */
cpukit/libmisc/monitor/monitor.h:291:#define RTEMS_MONITOR_RESPONSE_QUEUE_NAME (rtems_build_name('R', 'M', 'R', 'Q'))
cpukit/libmisc/monitor/monitor.h:319:extern uint32_t   rtems_monitor_default_node;  /* current default for commands */
cpukit/libmisc/monitor/monitor.h:353:typedef const void *(*rtems_monitor_object_next_fn)(void *, void *, rtems_id *);
cpukit/libmisc/monitor/monitor.h:368:typedef bool (*rtems_monitor_per_command_routine)(const rtems_monitor_command_entry_t *, void *);
cpukit/libmisc/monitor/monitor.h:371:void    rtems_monitor_pause_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:372:void    rtems_monitor_fatal_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:373:void    rtems_monitor_continue_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:374:void    rtems_monitor_debugger_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:375:void    rtems_monitor_reset_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:376:void    rtems_monitor_node_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:380:void rtems_monitor_command_iterate(rtems_monitor_per_command_routine routine, void *arg);
cpukit/libmisc/monitor/monitor.h:390:rtems_status_code rtems_monitor_server_request(uint32_t  , rtems_monitor_server_request_t *, rtems_monitor_server_response_t *);
cpukit/libmisc/monitor/monitor.h:397:void    rtems_monitor_command_usage(const rtems_monitor_command_entry_t *, const char *);
cpukit/libmisc/monitor/monitor.h:398:void    rtems_monitor_help_cmd(int, char **, const rtems_monitor_command_arg_t *, bool);
cpukit/libmisc/monitor/monitor.h:399:const rtems_monitor_command_entry_t *rtems_monitor_command_lookup(const char *name);
cpukit/libmisc/monitor/monitor.h:417:rtems_id   rtems_monitor_id_fixup(rtems_id, uint32_t  , rtems_monitor_object_type_t);
cpukit/libmisc/monitor/monitor.h:418:const rtems_monitor_object_info_t *rtems_monitor_object_lookup(rtems_monitor_object_type_t type);
cpukit/libmisc/monitor/monitor.h:419:rtems_id   rtems_monitor_object_canonical_get(rtems_monitor_object_type_t, rtems_id, void *, size_t *size_p);
cpukit/libmisc/monitor/monitor.h:420:rtems_id   rtems_monitor_object_canonical_next(const rtems_monitor_object_info_t *, rtems_id, void *);
cpukit/libmisc/monitor/monitor.h:423:void       rtems_monitor_object_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/monitor.h:429:void       rtems_monitor_config_canonical(rtems_monitor_config_t *, const void *);
cpukit/libmisc/monitor/monitor.h:430:const void *rtems_monitor_config_next(void *, rtems_monitor_config_t *, rtems_id *);
cpukit/libmisc/monitor/monitor.h:437:const void *rtems_monitor_mpci_next(void *, rtems_monitor_mpci_t *, rtems_id *);
cpukit/libmisc/monitor/monitor.h:443:void       rtems_monitor_init_task_canonical(rtems_monitor_init_task_t *, const void *);
cpukit/libmisc/monitor/monitor.h:444:const void *rtems_monitor_init_task_next(void *, rtems_monitor_init_task_t *, rtems_id *);
cpukit/libmisc/monitor/monitor.h:446:void       rtems_monitor_init_task_dump(rtems_monitor_init_task_t *, bool verbose);
cpukit/libmisc/monitor/monitor.h:449:void       rtems_monitor_extension_canonical(rtems_monitor_extension_t *, const void *);
cpukit/libmisc/monitor/monitor.h:469:void    rtems_monitor_region_canonical(rtems_monitor_region_t *, const void *);
cpukit/libmisc/monitor/monitor.h:479:const void *rtems_monitor_driver_next(void *, rtems_monitor_driver_t *, rtems_id *);
cpukit/libmisc/monitor/monitor.h:480:void     rtems_monitor_driver_canonical(rtems_monitor_driver_t *, const void *);
cpukit/libmisc/monitor/monitor.h:488:rtems_symbol_t *rtems_symbol_create(rtems_symbol_table_t *, const char *, uint32_t);
cpukit/libmisc/monitor/monitor.h:490:const rtems_symbol_t *rtems_symbol_value_lookup_exact(rtems_symbol_table_t *, uint32_t);
cpukit/libmisc/monitor/monitor.h:491:rtems_symbol_t *rtems_symbol_name_lookup(rtems_symbol_table_t *, const char *);
cpukit/libmisc/monitor/monitor.h:492:const void *rtems_monitor_symbol_next(void *object_info, rtems_monitor_symbol_t *, rtems_id *);
cpukit/libmisc/monitor/monitor.h:493:void    rtems_monitor_symbol_canonical(rtems_monitor_symbol_t *, rtems_symbol_t *);
cpukit/libmisc/monitor/monitor.h:494:void    rtems_monitor_symbol_canonical_by_name(rtems_monitor_symbol_t *, const char *);
cpukit/libmisc/monitor/monitor.h:495:void    rtems_monitor_symbol_canonical_by_value(rtems_monitor_symbol_t *, void *);
cpukit/libmisc/monitor/monitor.h:497:void    rtems_monitor_symbol_cmd(int, char **, const rtems_monitor_command_arg_t*, bool);
cpukit/libmisc/monitor/mon-editor.c:76:static char history_buffer[RTEMS_COMMAND_HISTORIES][RTEMS_COMMAND_BUFFER_SIZE];
cpukit/libmisc/monitor/mon-editor.c:295:             * If we are moving up the histories then we need to save the working
cpukit/libmisc/monitor/mon-editor.c:403:                         RTEMS_COMMAND_BUFFER_SIZE * (RTEMS_COMMAND_HISTORIES - 1));
cpukit/libmisc/monitor/mon-editor.c:405:                         sizeof (history_pos[0]) * (RTEMS_COMMAND_HISTORIES - 1));
cpukit/libmisc/fb/mw_uid.h:135:extern int uid_read_message( struct MW_UID_MESSAGE *m, unsigned long timeout );
cpukit/libmisc/fb/mw_uid.c:100:  } else if( ( status == RTEMS_UNSATISFIED ) || ( status == RTEMS_TIMEOUT ) ) {
cpukit/libmisc/uuid/uuid.h:58:#define UUID_DEFINE(name,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15) \
cpukit/libmisc/uuid/uuid.h:59:	static const uuid_t name __attribute__ ((unused)) = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}
cpukit/libmisc/uuid/uuid.h:61:#define UUID_DEFINE(name,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15) \
cpukit/libmisc/uuid/uuid.h:62:	static const uuid_t name = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}
cpukit/libmisc/uuid/gen_uuid.c:171:		srand((getpid() << ((sizeof(pid_t)*CHAR_BIT)>>1)) ^ getuid() ^ tv.tv_sec ^ tv.tv_usec);
cpukit/libmisc/uuid/gen_uuid.c:235: * http://www.codeguru.com/cpp/i-n/network/networkinformation/article.php/c5451
cpukit/libmisc/mouse/serial_mouse.c:173:      args->ioctl_return = ioctl(serial_mouse_fd, args->command, args->buffer );
cpukit/libmisc/stringto/stringtolonglong.c:60:    (( result == 0 ) || ( result == LONG_LONG_MAX ) || ( result == LONG_LONG_MIN )))
cpukit/libmisc/stringto/stringtopointer.c:28:#define STRTOFUNC(a,b,c)	rtems_string_to_unsigned_long(a, (unsigned long*) b, c, 0)
cpukit/libmisc/stringto/stringtopointer.c:30:#define STRTOFUNC(a,b,c)	rtems_string_to_unsigned_long_long(a, (unsigned long long*) b, c, 0)
cpukit/libmisc/stringto/stringtopointer.c:32:#define STRTOFUNC(a,b,c)	rtems_string_to_unsigned_int(a, (unsigned int*) b, c, 0)
cpukit/libmisc/stringto/stringtopointer.c:35:#define STRTOFUNC(a,b,c)	rtems_string_to_unsigned_long(a, (unsigned long*) b, c, 0)
cpukit/libmisc/fsmount/fsmount.c:49:  | Purpose:                                                                  |
cpukit/libmisc/fsmount/fsmount.c:50:  |  This function will create the mount points listed and mount the file     |
cpukit/libmisc/fsmount/fsmount.c:51:  |   systems listed in the calling parameters                                |
cpukit/libmisc/fsmount/fsmount.c:52:  +---------------------------------------------------------------------------+
cpukit/libmisc/fsmount/fsmount.c:53:  | Input Parameters:                                                         |
cpukit/libmisc/fsmount/fsmount.c:54:  \*-------------------------------------------------------------------------*/
cpukit/libmisc/fsmount/fsmount.c:60:  | Return Value:                                                             |
cpukit/libmisc/fsmount/fsmount.c:61:  |    0, if success, -1 and errno if failed                                  |
cpukit/libmisc/fsmount/fsmount.c:62:  \*=========================================================================*/
cpukit/libmisc/fsmount/fsmount.c:82:          fprintf(stdout,"fsmount: creation of mount point \"%s\" failed: %s\n",
cpukit/libmisc/fsmount/fsmount.h:130: * In case of an abort condition the corresponding table index will be reported
cpukit/libmisc/fsmount/fsmount.h:135: * On success, zero is returned.  On error, -1 is returned, and @c errno is set
cpukit/libmisc/fsmount/fsmount.h:141: * Card.  Some cards do not have a partition table so at first it tries to find
cpukit/libmisc/fsmount/fsmount.h:142: * a file system inside the hole disk.  If this is successful the mount process
cpukit/libmisc/fsmount/fsmount.h:187: *   rv = rtems_fsmount(fstab, sizeof(fstab) / sizeof(fstab [0]), &abort_index);
cpukit/libmisc/fsmount/fsmount.h:195:int rtems_fsmount( const rtems_fstab_entry *fstab, size_t size, size_t *abort_index);
cpukit/libmisc/cpuuse/cpuusagereport.c:102:     "-------------------------------------------------------------------------------\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:104:     "------------+----------------------------------------+---------------+---------\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:106:       " ID         | NAME                                   | SECONDS       | PERCENT\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:108:       " ID         | NAME                                   | TICKS         | PERCENT\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:110:     "------------+----------------------------------------+---------------+---------\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:199:       "------------+----------------------------------------+---------------+---------\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:200:       " TIME SINCE LAST CPU USAGE RESET IN SECONDS:                    %7" PRIu32 ".%06" PRIu32 "\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:201:       "-------------------------------------------------------------------------------\n",
cpukit/libmisc/cpuuse/cpuusagereport.c:207:       "------------+----------------------------------------+---------------+---------\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:208:       " TICKS SINCE LAST SYSTEM RESET:                                 %14" PRIu32 "\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:209:       " TOTAL UNITS:                                                   %14" PRIu32 "\n"
cpukit/libmisc/cpuuse/cpuusagereport.c:210:       "-------------------------------------------------------------------------------\n",
cpukit/rtems/include/rtems.h:160: * least RTEMS_MINIMUM_STACK_SIZE bytes in size. If the user configured minimum
cpukit/rtems/include/rtems.h:166: * @brief Specifies that the task should be created with the configured minimum
cpukit/rtems/include/rtems.h:174: * minimum stack size value, you may get a stack size that is smaller or larger
cpukit/rtems/include/rtems/rtems/object.h:45:  /** This field is the number of object instances configured for this class. */
cpukit/rtems/include/rtems/rtems/ratemon.h:51: *  for both cpu usage and wall time.  The statistics indicate the execution time
cpukit/rtems/include/rtems/rtems/ratemon.h:52: *  used by the owning thread between successive calls to rtems_rate_monotonic_period.
cpukit/rtems/include/rtems/rtems/ratemon.h:132: *  The following constant is the interval passed to the rate_monontonic_period
cpukit/rtems/include/rtems/rtems/cache.h:22: *  specific function, the CPU dependent routine does nothing (but does exist).
cpukit/rtems/include/rtems/rtems/cache.h:25: *  support for BSP specific issues such as a secondary cache. In such a system,
cpukit/rtems/include/rtems/rtems/cache.h:117:void rtems_cache_invalidate_multiple_instruction_lines( const void *, size_t );
cpukit/rtems/include/rtems/rtems/types.h:186: * @brief Prefix found at the beginning of each MPCI packet sent between nodes.
cpukit/rtems/include/rtems/rtems/barrier.h:92: *  @param[in] attribute_set specifies the attributes of this barrier instance.
cpukit/rtems/include/rtems/rtems/support.h:35: * @brief Returns the number of micro seconds for the milli seconds value @a _ms.
cpukit/rtems/include/rtems/rtems/support.h:106: *  specified by @a block_sizes.  The @a block_sizes must point to an array with
cpukit/rtems/include/rtems/rtems/intr.h:6: *  This include file contains all the constants and structures associated with
cpukit/rtems/include/rtems/rtems/intr.h:69: *  routine for the interrupt vector with number @a vector.  The previous RTEMS
cpukit/rtems/include/rtems/rtems/event.h:63: *  The application developer should remember the following key characteristics
cpukit/rtems/include/rtems/rtems/event.h:71: *  - Events are not queued. In other words, if an event is sent more than once
cpukit/rtems/include/rtems/rtems/event.h:76: *  event is an event that has been posted but not received. An event condition
cpukit/rtems/include/rtems/rtems/event.h:78: *  algorithm which will be used to determine when the request is satisfied. An
cpukit/rtems/include/rtems/rtems/event.h:87: *  If an event is not explicitly specified in the set or condition, then it is
cpukit/rtems/include/rtems/rtems/event.h:89: *  therefore bitwise or and addition operations are equivalent as long as each
cpukit/rtems/include/rtems/rtems/event.h:116: *  Identical events sent to a task are not queued. In other words, the second,
cpukit/rtems/include/rtems/rtems/event.h:147: *  for the event condition to be satisfied.  The @ref RTEMS_EVENT_ANY and @ref
cpukit/rtems/include/rtems/rtems/event.h:150: *  the event condition.  The @a event_out parameter is returned to the calling
cpukit/rtems/include/rtems/rtems/event.h:151: *  task with the value that corresponds to the events in @a event_in that were
cpukit/rtems/include/rtems/rtems/event.h:155: *  @ref RTEMS_PENDING_EVENTS for the input event set @a event_in.  The pending
cpukit/rtems/include/rtems/rtems/event.h:159: *  A task can receive all of the currently pending events by using the a value
cpukit/rtems/include/rtems/rtems/event.h:161: *  @ref RTEMS_NO_WAIT | @ref RTEMS_EVENT_ANY for the option set @a option_set.
cpukit/rtems/include/rtems/rtems/event.h:168: *  cleared.  If the event condition is not satisfied and @ref RTEMS_NO_WAIT is
cpukit/rtems/include/rtems/rtems/event.h:173: *  If the calling task must wait for the event condition to be satisfied, then
cpukit/rtems/include/rtems/rtems/event.h:175: *  it is set to @ref RTEMS_NO_TIMEOUT, then the calling task will wait forever.
cpukit/rtems/include/rtems/rtems/event.h:181: *  A clock tick is required to support the wait with time out functionality of
cpukit/rtems/include/rtems/rtems/event.h:219: * See also @ref ClassicEventTransient.  This event may be used by every entity
cpukit/rtems/include/rtems/rtems/event.h:267: * transient event to the client task to notify about a request completion, see
cpukit/rtems/include/rtems/rtems/event.h:281: *   M [label="Main Task"], IDLE [label="Idle Task"], S [label="Server"], TIME [label="System Tick Handler"];
cpukit/rtems/include/rtems/rtems/event.h:284: *   M box M [label="prepare request\nissue request\nrtems_event_transient_receive()"];
cpukit/rtems/include/rtems/rtems/event.h:299: *   M box M [label="prepare request\nissue request\nrtems_event_transient_receive()"];
cpukit/rtems/include/rtems/rtems/event.h:307: * Suppose you have a task that wants to issue a certain request and then waits
cpukit/rtems/include/rtems/rtems/event.h:311: * reception of the transient event.  Once the server task is finished with the
cpukit/rtems/src/timerserver.c:137:   *  from the last snapshot to now may be arbitrarily long.  The last snapshot
cpukit/rtems/src/timerserver.c:138:   *  is the reference point for the delta chain.  Thus if we do not update the
cpukit/rtems/src/timerserver.c:179:     *  We have to advance the last known seconds value of the server and update
cpukit/rtems/src/timerserver.c:230:     *  server is not preemptible, so we must be in interrupt context here.  No
cpukit/rtems/src/timerserver.c:330:     *  current time.  In case someone inserts a watchdog with an initial value
cpukit/rtems/src/timerserver.c:369:    _Timer_server_Get_watchdogs_that_fire_now( ts, &insert_chain, &fire_chain );
cpukit/rtems/src/timerserver.c:380:         *  It is essential that interrupts are disable here since an interrupt
cpukit/rtems/src/timerserver.c:548:  ts->TOD_watchdogs.last_snapshot = (Watchdog_Interval) _TOD_Seconds_since_epoch();
cpukit/rtems/src/semflush.c:58:      if ( !_Attributes_Is_counting_semaphore(the_semaphore->attribute_set) ) {
cpukit/rtems/src/taskcreate.c:89:   *  Validate the RTEMS API priority and convert it to the core priority range.
cpukit/rtems/src/event.c:41:  _MPCI_Register_packet_processor( MP_PACKET_EVENT, _Event_MP_Process_packet );
cpukit/rtems/src/msgqbroadcast.c:75:        _Message_queue_Translate_core_message_queue_return_code( core_status );
cpukit/rtems/src/workspacegreedy.c:37:  opaque = _Heap_Greedy_allocate( &_Workspace_Area, block_sizes, block_count );
cpukit/rtems/src/ratemonperiod.c:76:      if (_Timestamp_Less_than(&used, &the_period->cpu_usage_period_initiated))
cpukit/rtems/src/ratemonperiod.c:214:    if ( _Timestamp_Greater_than( &since_last_period, &stats->max_wall_time ) )
cpukit/rtems/src/ratemongetstatistics.c:56:        _Timestamp_To_timespec( &src->total_wall_time, &dst->total_wall_time );
cpukit/rtems/src/regionreturnsegment.c:62:        if ( !_Heap_Size_of_alloc_area( &the_region->Memory, segment, &size ) )
cpukit/rtems/src/msgqcreate.c:114:                              name, the_message_queue->Object.id, false ) ) ) {
cpukit/rtems/src/clockget.c:53:      return rtems_clock_get_seconds_since_epoch((rtems_interval *)time_buffer);
cpukit/rtems/src/semdelete.c:82:      if ( !_Attributes_Is_counting_semaphore(the_semaphore->attribute_set) ) {
cpukit/rtems/src/semdelete.c:109:        _Objects_MP_Close( &_Semaphore_Information, the_semaphore->Object.id );
cpukit/rtems/src/dpmem.c:46:    false,                        /* true if names of this object are strings */
cpukit/rtems/src/msg.c:57:    false,                        /* true if names of this object are strings */
cpukit/rtems/src/taskinitusers.c:78:      _Internal_error_Occurred( INTERNAL_ERROR_RTEMS_API, true, return_value );
cpukit/rtems/src/taskinitusers.c:86:      _Internal_error_Occurred( INTERNAL_ERROR_RTEMS_API, true, return_value );
cpukit/rtems/src/msgqsend.c:38: *  This routine implements the directive rtems_message_queue_send.  It sends a
cpukit/rtems/src/taskident.c:65:  status = _Objects_Name_to_id_u32( &_RTEMS_tasks_Information, name, node, id );
cpukit/rtems/src/taskdelete.c:76:          _Objects_MP_Close( &_RTEMS_tasks_Information, the_thread->Object.id );
cpukit/rtems/src/regionextend.c:29: *  This directive attempts to grow a region of physical contiguous memory area
cpukit/rtems/src/taskmode.c:87:      executing->budget_algorithm = THREAD_CPU_BUDGET_ALGORITHM_RESET_TIMESLICE;
cpukit/rtems/src/ratemon.c:53:    false,                           /* true if this is a global object class */
cpukit/rtems/src/semobtain.c:79:      if ( !_Attributes_Is_counting_semaphore(the_semaphore->attribute_set) ) {
cpukit/rtems/src/ratemonreportstatistics.c:61:1234567890123456789012345678901234567890123456789012345678901234567890123456789\
cpukit/rtems/src/ratemonreportstatistics.c:68:1234567890123456789012345678901234567890123456789012345678901234567890123456789\
cpukit/rtems/src/taskstart.c:66:             the_thread, THREAD_START_NUMERIC, entry_point, NULL, argument ) ) {
cpukit/rtems/src/msgmp.c:171:      _Thread_Executing->Wait.return_argument_second.immutable_object = buffer;
cpukit/rtems/src/semrelease.c:82:      if ( !_Attributes_Is_counting_semaphore(the_semaphore->attribute_set) ) {
cpukit/rtems/inline/rtems/rtems/asr.inl:17:# error "Never use <rtems/rtems/asr.inl> directly; include <rtems/rtems/asr.h> instead."
cpukit/rtems/inline/rtems/rtems/region.inl:17:# error "Never use <rtems/rtems/region.inl> directly; include <rtems/rtems/region.h> instead."
cpukit/rtems/inline/rtems/rtems/barrier.inl:18:# error "Never use <rtems/rtems/barrier.inl> directly; include <rtems/rtems/barrier.h> instead."
cpukit/rtems/inline/rtems/rtems/timer.inl:18:# error "Never use <rtems/rtems/timer.inl> directly; include <rtems/rtems/timer.h> instead."
cpukit/rtems/inline/rtems/rtems/timer.inl:81:  return (the_class == TIMER_INTERVAL) || (the_class == TIMER_INTERVAL_ON_TASK);
cpukit/rtems/inline/rtems/rtems/tasks.inl:17:# error "Never use <rtems/rtems/tasks.inl> directly; include <rtems/rtems/tasks.h> instead."
cpukit/rtems/inline/rtems/rtems/message.inl:17:# error "Never use <rtems/rtems/message.inl> directly; include <rtems/rtems/message.h> instead."
cpukit/rtems/inline/rtems/rtems/part.inl:17:# error "Never use <rtems/rtems/part.inl> directly; include <rtems/rtems/part.h> instead."
cpukit/rtems/inline/rtems/rtems/options.inl:17:# error "Never use <rtems/rtems/options.inl> directly; include <rtems/rtems/options.h> instead."
cpukit/rtems/inline/rtems/rtems/status.inl:17:# error "Never use <rtems/rtems/status.inl> directly; include <rtems/rtems/status.h> instead."
cpukit/rtems/inline/rtems/rtems/status.inl:33: *  This function returns TRUE if the status code is equal to RTEMS_SUCCESSFUL,
cpukit/rtems/inline/rtems/rtems/event.inl:17:# error "Never use <rtems/rtems/event.inl> directly; include <rtems/rtems/event.h> instead."
cpukit/rtems/inline/rtems/rtems/eventset.inl:16:# error "Never use <rtems/rtems/eventset.inl> directly; include <rtems/rtems/eventset.h> instead."
cpukit/rtems/inline/rtems/rtems/sem.inl:17:# error "Never use <rtems/rtems/sem.inl> directly; include <rtems/rtems/sem.h> instead."
cpukit/rtems/inline/rtems/rtems/dpmem.inl:17:# error "Never use <rtems/rtems/dpmem.inl> directly; include <rtems/rtems/dpmem.h> instead."
cpukit/rtems/inline/rtems/rtems/modes.inl:17:# error "Never use <rtems/rtems/modes.inl> directly; include <rtems/rtems/modes.h> instead."
cpukit/rtems/inline/rtems/rtems/support.inl:18:# error "Never use <rtems/rtems/support.inl> directly; include <rtems/rtems/support.h> instead."
cpukit/rtems/inline/rtems/rtems/ratemon.inl:17:# error "Never use <rtems/rtems/ratemon.inl> directly; include <rtems/rtems/ratemon.h> instead."
cpukit/rtems/inline/rtems/rtems/attr.inl:18:# error "Never use <rtems/rtems/attr.inl> directly; include <rtems/rtems/attr.h> instead."
cpukit/rtems/inline/rtems/rtems/attr.inl:124:    ((attribute_set & RTEMS_SEMAPHORE_CLASS) == RTEMS_SIMPLE_BINARY_SEMAPHORE);
cpukit/rtems/inline/rtems/rtems/attr.inl:137:  return ((attribute_set & RTEMS_SEMAPHORE_CLASS) == RTEMS_COUNTING_SEMAPHORE);
cpukit/rtems/mainpage.h:31: * software. The trend in computing costs is the complete dominance of software
cpukit/rtems/mainpage.h:45: * definition to allow portable application development has only recently begun
cpukit/rtems/mainpage.h:60: * This emerging standard defines an interface for the development of real-time
cpukit/rtems/mainpage.h:82: * task regardless of which processor the object and the accessing task reside.
cpukit/rtems/mainpage.h:85: * advantages enjoyed from the push for UNIX standardization by AT&T's System V
cpukit/rtems/mainpage.h:113: * Another conclusion drawn from the analysis, was that the run time executives
cpukit/rtems/mainpage.h:115: * used in modern missile systems. A run time executive is the core part of the
cpukit/rtems/mainpage.h:118: * whenever efficient executive (also known as kernel) code was required by the
cpukit/rtems/mainpage.h:119: * application, the user developed in-house software. This software was usually
cpukit/rtems/mainpage.h:125: * third party kernel code. The contractor, and eventually the Government, must
cpukit/rtems/mainpage.h:132: * source code were available. Responsibility for system failures due to faulty
cpukit/rtems/mainpage.h:136: * address these problems. A project to develop an experimental run time kernel
cpukit/rtems/mainpage.h:138: * language mentioned above. The Real Time Executive for Multiprocessor Systems
cpukit/rtems/mainpage.h:169: * allows a much easier transition from one processor family to another without
cpukit/rtems/mainpage.h:173: * not claim compliance. However, the status of the standard is being carefully
cpukit/rtems/mainpage.h:203: * @section RTEMSOverviewSecRealtimeApplicationSystems Real-time Application Systems
cpukit/rtems/mainpage.h:209: * of computations, but also on the time at which the results are produced. The
cpukit/rtems/mainpage.h:212: * rigid and critical time constraints referred to as deadlines. Systems can be
cpukit/rtems/mainpage.h:216: * Deadlines can be further characterized as either hard or soft based upon the
cpukit/rtems/mainpage.h:217: * value of the results when produced after the deadline has passed. A deadline
cpukit/rtems/mainpage.h:252: * executive system calls effectively extend the CPU instruction set to support
cpukit/rtems/mainpage.h:257: * By proper grouping of responses to stimuli into separate tasks, a system can
cpukit/rtems/mainpage.h:258: * now asynchronously switch between independent streams of execution, directly
cpukit/rtems/mainpage.h:265: * the system designer, enabling more critical aspects of the system to receive
cpukit/rtems/mainpage.h:268: * environment for which it is designed. As a result, the system will always be
cpukit/rtems/mainpage.h:280: * @section RTEMSOverviewSecApplicationArchitecture RTEMS Application Architecture
cpukit/rtems/mainpage.h:290: * The RTEMS I/O interface manager provides an efficient tool for incorporating
cpukit/rtems/mainpage.h:291: * these hardware dependencies into the system while simultaneously providing a
cpukit/rtems/mainpage.h:294: * rich library of standard application components which can be used repeatedly
cpukit/rtems/mainpage.h:301: * interface presented to the application is formed by grouping directives into
cpukit/rtems/mainpage.h:303: * managers such as scheduling, dispatching, and object management are provided
cpukit/rtems/mainpage.h:306: * environment that promotes the development of efficient real-time application
cpukit/rtems/mainpage.h:332: * @section RTEMSOverviewSecUserCustomization User Customization and Extensibility
cpukit/rtems/mainpage.h:335: * increasingly common in a variety of embedded systems. A wide range of custom
cpukit/rtems/mainpage.h:338: * characteristics of individual microprocessor families or of specific support
cpukit/rtems/mainpage.h:351: * Since RTEMS is designed to isolate the hardware dependencies in the specific
cpukit/rtems/mainpage.h:352: * board support packages, the real-time application should be easily ported to
cpukit/rtems/mainpage.h:360: * RTEMS was specifically designed to automatically leave out all services that
cpukit/rtems/mainpage.h:361: * are not required from the run-time environment. Features such as networking,
cpukit/rtems/mainpage.h:385: * programming language is required to fully understand the material presented.
cpukit/rtems/mainpage.h:387: * users will find that the use and behavior of the two implementations is very
cpukit/rtems/mainpage.h:390: * executive cannot be obtained without studying the entire manual because many
cpukit/rtems/mainpage.h:414: * All objects are created on the local node as required by the application and
cpukit/rtems/mainpage.h:415: * have an RTEMS assigned ID. All objects have a user-assigned name. Although a
cpukit/rtems/mainpage.h:425: * object by the user. The data type @ref rtems_name is used to store object names.
cpukit/rtems/mainpage.h:443: * RTEMS provides a helper routine, rtems_object_get_name(), which can be used to
cpukit/rtems/mainpage.h:444: * obtain the name of any RTEMS object using just its ID. This routine attempts
cpukit/rtems/mainpage.h:449: * An object ID is a unique unsigned integer value which uniquely identifies an
cpukit/rtems/mainpage.h:452: * efficient manipulation of object IDs is critical to the performance of RTEMS
cpukit/rtems/mainpage.h:460: * @subsubsection ClassicRTEMSSubSec32BitObjectIdentifierFormat 32-Bit Object Identifier Format
cpukit/rtems/mainpage.h:469: *     <td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td>
cpukit/rtems/mainpage.h:470: *     <td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td>
cpukit/rtems/mainpage.h:471: *     <td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>09</td><td>08</td>
cpukit/rtems/mainpage.h:472: *     <td>07</td><td>06</td><td>05</td><td>04</td><td>03</td><td>02</td><td>01</td><td>00</td>
cpukit/rtems/mainpage.h:476: *     <td colspan=5>Class</td><td colspan=3>API</td><td colspan=8>Node</td><td colspan=16>Object Index</td>
cpukit/rtems/mainpage.h:488: * @subsubsection ClassicRTEMSSubSec16BitObjectIdentifierFormat 16-Bit Object Identifier Format
cpukit/rtems/mainpage.h:496: *     <td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>09</td><td>08</td>
cpukit/rtems/mainpage.h:497: *     <td>07</td><td>06</td><td>05</td><td>04</td><td>03</td><td>02</td><td>01</td><td>00</td>
cpukit/rtems/mainpage.h:501: *     <td colspan=5>Class</td><td colspan=3>API</td><td colspan=8>Object Index</td>
cpukit/rtems/mainpage.h:509: * and single processor systems. As this format is typically utilized by 16-bit
cpukit/rtems/mainpage.h:513: * @subsection ClassicRTEMSSubSecObjectIdentiferDescription Object Identifer Description
cpukit/rtems/mainpage.h:515: * The components of an object ID make it possible to quickly locate any object
cpukit/rtems/mainpage.h:518: * corresponding ID is returned by the appropriate object create directive. The
cpukit/rtems/mainpage.h:527: * object is created, the object identification directives are not necessary in
cpukit/rtems/mainpage.h:531: * an RTEMS ID. These services are described in detail later in this manual but
cpukit/rtems/mainpage.h:540: * the information necessary to manage a particular object type. For efficiency
cpukit/rtems/mainpage.h:542: * However, many of the fields are similar in function. The number of each type
cpukit/rtems/mainpage.h:561: * Most RTEMS managers can be used to provide some form of communication and/or
cpukit/rtems/mainpage.h:580: * supports only asynchronous communication and is typically used for exception
cpukit/rtems/mainpage.h:588: * ticks is completely application dependent and determines the granularity and
cpukit/rtems/mainpage.h:608: * that a set of independent periodic tasks will always meet their deadlines --
cpukit/rtems/mainpage.h:615: * maintains the current date and time. This allows selected time operations to
cpukit/rtems/mainpage.h:681: * During system initialization, RTEMS reserves a TCB for each task configured.
cpukit/rtems/mainpage.h:682: * A TCB is allocated upon creation of the task and is returned to the TCB free
cpukit/rtems/mainpage.h:694: * task regains control of the processor, its context is restored from the TCB.
cpukit/rtems/mainpage.h:695: * When a task is restarted, the initial state of the task is restored from the
cpukit/rtems/mainpage.h:714: * scheduling algorithm. The scheduling of a task is based on its current state
cpukit/rtems/mainpage.h:725: * tasks of numerically larger priority values. For example, a task at priority
cpukit/rtems/mainpage.h:726: * level 5 is of higher privilege than a task at priority level 10. There is no
cpukit/rtems/mainpage.h:776: * only tasks which have established a routine to process asynchronous signals.
cpukit/rtems/mainpage.h:810: * @section ClassicTasksSecFloatingPointConsiderations Floating Point Considerations
cpukit/rtems/mainpage.h:812: * Creating a task with the @ref RTEMS_FLOATING_POINT attribute flag results in
cpukit/rtems/mainpage.h:823: * unnecessarily saving and restoring the state of the numeric coprocessor. The
cpukit/rtems/mainpage.h:843: * If the supported processor type does not have hardware floating capabilities
cpukit/rtems/mainpage.h:862: * private (i.e. per-task) the task can access and modify the variable, but the
cpukit/rtems/mainpage.h:863: * modifications will not appear to other tasks, and other tasks' modifications
cpukit/rtems/mainpage.h:870: * location shared among tasks, can not be affected by a task once it has added
cpukit/rtems/mainpage.h:872: * will not affect the value seen by a task which has added the variable to its
cpukit/rtems/mainpage.h:878: * global variables. To make a variable not shareable (i.e. a "global" variable
cpukit/rtems/mainpage.h:886: * dynamically allocated structure containing the task's private "global" data.
cpukit/rtems/mainpage.h:891: * @section ClassicTasksSecBuildingTaskAttributeSet Building a Task Attribute Set
cpukit/rtems/mainpage.h:905: * good programming practice to specify default components. If all defaults are
cpukit/rtems/mainpage.h:907: * demonstrates the attribute_set parameter needed to create a local task which
cpukit/rtems/mainpage.h:923: * <tr><td>@ref RTEMS_PREEMPT</td><td>@ref RTEMS_PREEMPT_MASK</td><td>enables preemption</td></tr>
cpukit/rtems/mainpage.h:924: * <tr><td>@ref RTEMS_NO_PREEMPT</td><td>@ref RTEMS_PREEMPT_MASK</td><td>disables preemption</td></tr>
cpukit/rtems/mainpage.h:925: * <tr><td>@ref RTEMS_NO_TIMESLICE</td><td>@ref RTEMS_TIMESLICE_MASK</td><td>disables timeslicing</td></tr>
cpukit/rtems/mainpage.h:926: * <tr><td>@ref RTEMS_TIMESLICE</td><td>@ref RTEMS_TIMESLICE_MASK</td><td>enables timeslicing</td></tr>
cpukit/rtems/mainpage.h:927: * <tr><td>@ref RTEMS_ASR</td><td>@ref RTEMS_ASR_MASK</td><td>enables ASR processing</td></tr>
cpukit/rtems/mainpage.h:928: * <tr><td>@ref RTEMS_NO_ASR</td><td>@ref RTEMS_ASR_MASK</td><td>disables ASR processing</td></tr>
cpukit/rtems/mainpage.h:929: * <tr><td>@ref RTEMS_INTERRUPT_LEVEL(0)</td><td>@ref RTEMS_INTERRUPT_MASK</td><td>enables all interrupts</td></tr>
cpukit/rtems/mainpage.h:930: * <tr><td>@ref RTEMS_INTERRUPT_LEVEL(n)</td><td>@ref RTEMS_INTERRUPT_MASK</td><td>sets interrupts level n</td></tr>
cpukit/rtems/mainpage.h:936: * default is not required to appear in the mode component list, although it is
cpukit/posix/include/aio.h:56:                          /*   the operation is performed and no notification */
cpukit/posix/include/aio.h:57:                          /*   shall be given when the operation is completed */
cpukit/posix/include/rtems/posix/priority.h:27: *  Thus, RTEMS Core has priorities run in the opposite sense of the POSIX API.
cpukit/posix/include/rtems/posix/priority.h:51: *  Thus, RTEMS Core has priorities run in the opposite sense of the POSIX API.
cpukit/posix/include/rtems/posix/cond.h:108:RTEMS_INLINE_ROUTINE POSIX_Condition_variables_Control *_POSIX_Condition_variables_Get (
cpukit/posix/include/rtems/posix/mqueue.h:143:RTEMS_INLINE_ROUTINE POSIX_Message_queue_Control *_POSIX_Message_queue_Allocate( void );
cpukit/posix/include/rtems/posix/mqueue.h:182: *  This function returns TRUE if the_message_queue is NULL and FALSE otherwise.
cpukit/posix/include/rtems/posix/mqueue.h:197:RTEMS_INLINE_ROUTINE CORE_message_queue_Submit_types _POSIX_Message_queue_Priority_to_core(
cpukit/posix/include/rtems/posix/pthread.h:95: *  @return This methods returns a pointer to the corresponding Thread_Control.
cpukit/posix/include/rtems/posix/semaphore.h:75:RTEMS_INLINE_ROUTINE POSIX_Semaphore_Control *_POSIX_Semaphore_Allocate( void );
cpukit/posix/src/semwait.c:38:  return _POSIX_Semaphore_Wait_support( sem, true, THREAD_QUEUE_WAIT_FOREVER );
cpukit/posix/src/mqueuenotify.c:81:        if ( _CORE_message_queue_Is_notify_enabled( &the_mq->Message_queue ) ) {
cpukit/posix/src/psignalunblockthread.c:56:    if ( (the_thread->Wait.option & mask) || (~api->signals_blocked & mask) ) {
cpukit/posix/src/pspin.c:48:    _POSIX_PATH_MAX                  /* maximum length of each object's name */
cpukit/posix/src/pspin.c:51:    false,                           /* true if this is a global object class */
cpukit/posix/src/ptimer.c:62:    true,                       /* true if names for this object are strings */
cpukit/posix/src/killinfo.c:182:  for (the_api = OBJECTS_CLASSIC_API; the_api <= OBJECTS_APIS_LAST; the_api++) {
cpukit/posix/src/killinfo.c:277:        if ( !_States_Is_interruptible_by_signal(interested->current_state) ) {
cpukit/posix/src/killinfo.c:279:          if ( _States_Is_interruptible_by_signal(the_thread->current_state) ) {
cpukit/posix/src/setcancelstate.c:57:    _POSIX_Thread_Evaluate_cancellation_and_enable_dispatch(_Thread_Executing);
cpukit/posix/src/mutexattrgetprioceiling.c:25: *  13.6.1 Mutex Initialization Scheduling Attributes, P1003.1c/Draft 10, p. 128
cpukit/posix/src/key.c:48:    true,                       /* true if names for this object are strings */
cpukit/posix/src/prwlocktrywrlock.c:2: *  POSIX RWLock Manager -- Attempt to Obtain a Write Lock on a RWLock Instance
cpukit/posix/src/aio_cancel.c:58:        r_chain = rtems_aio_search_fd (&aio_request_queue.idle_req, fildes, 0);
cpukit/posix/src/aio_cancel.c:99:        r_chain = rtems_aio_search_fd (&aio_request_queue.idle_req, fildes, 0);
cpukit/posix/src/sigtimedwait.c:161:  _POSIX_signals_Clear_signals( api, the_info->si_signo, the_info, false, false );
cpukit/posix/src/setcanceltype.c:48:  if ( type != PTHREAD_CANCEL_DEFERRED && type != PTHREAD_CANCEL_ASYNCHRONOUS )
cpukit/posix/src/setcanceltype.c:57:    _POSIX_Thread_Evaluate_cancellation_and_enable_dispatch(_Thread_Executing);
cpukit/posix/src/semaphorecreatesupp.c:104:  _CORE_semaphore_Initialize( &the_semaphore->Semaphore, the_sem_attr, value );
cpukit/posix/src/timersettime.c:80:      if ( normalize.it_value.tv_sec == 0 && normalize.it_value.tv_nsec == 0 ) {
cpukit/posix/src/prwlocktimedwrlock.c:2: *  POSIX RWLock Manager -- Attempt to Obtain a Write Lock on a RWLock Instance
cpukit/posix/src/prwlocktimedwrlock.c:82:           (_Thread_Executing->Wait.return_code == CORE_RWLOCK_UNAVAILABLE) ) {
cpukit/posix/src/mutex.c:68:    true,                       /* true if names for this object are strings */
cpukit/posix/src/cond.c:48:    true,                       /* true if names for this object are strings */
cpukit/posix/src/prwlocktimedrdlock.c:82:        if ( _Thread_Executing->Wait.return_code == CORE_RWLOCK_UNAVAILABLE ) {
cpukit/posix/src/mutexattrsetprotocol.c:25: *  13.6.1 Mutex Initialization Scheduling Attributes, P1003.1c/Draft 10, p. 128
cpukit/posix/src/pthread.c:132:  the_thread->cpu_time_budget = 0xFFFFFFFF; /* XXX should be based on MAX_U32 */
cpukit/posix/src/pthread.c:134:  new_priority = _POSIX_Priority_To_core(api->schedparam.sched_ss_low_priority);
cpukit/posix/src/pthread.c:345:    true,                        /* true if names for this object are strings */
cpukit/posix/src/pthreadequal.c:4: *  NOTE:  POSIX does not define the behavior when either thread id is invalid.
cpukit/posix/src/mutexattrsetprioceiling.c:25: *  13.6.1 Mutex Initialization Scheduling Attributes, P1003.1c/Draft 10, p. 128
cpukit/posix/src/mqueue.c:44: *  This routine initializes all message_queue manager related data structures.
cpukit/posix/src/mqueue.c:61:    true,                       /* true if names for this object are strings */
cpukit/posix/src/mqueue.c:76:    true,                       /* true if names for this object are strings */
cpukit/posix/src/semaphore.c:49:    true,                       /* true if names for this object are strings */
cpukit/posix/src/alarm.c:63:        ((the_timer->stop_time - the_timer->start_time) / TOD_TICKS_PER_SECOND);
cpukit/posix/src/semopen.c:97:    the_semaphore = _POSIX_Semaphore_Get( (sem_t *) &the_semaphore_id, &location );
cpukit/posix/src/mutexattrgetprotocol.c:25: *  13.6.1 Mutex Initialization Scheduling Attributes, P1003.1c/Draft 10, p. 128
cpukit/posix/src/nanosleep.c:87:      _Thread_Executing->Timer.stop_time - _Thread_Executing->Timer.start_time;
cpukit/posix/inline/rtems/posix/barrier.inl:18:# error "Never use <rtems/posix/barrier.inl> directly; include <rtems/posix/barrier.h> instead."
cpukit/posix/inline/rtems/posix/timer.inl:18:# error "Never use <rtems/posix/timer.inl> directly; include <rtems/posix/timer.h> instead."
cpukit/posix/inline/rtems/posix/timer.inl:35:  return (POSIX_Timer_Control *) _Objects_Allocate( &_POSIX_Timer_Information );
cpukit/posix/inline/rtems/posix/mutex.inl:17:# error "Never use <rtems/posix/mutex.inl> directly; include <rtems/posix/mutex.h> instead."
cpukit/posix/inline/rtems/posix/mutex.inl:29:  return (POSIX_Mutex_Control *) _Objects_Allocate( &_POSIX_Mutex_Information );
cpukit/posix/inline/rtems/posix/cond.inl:18:# error "Never use <rtems/posix/cond.inl> directly; include <rtems/posix/cond.h> instead."
cpukit/posix/inline/rtems/posix/pthread.inl:18:# error "Never use <rtems/posix/pthread.inl> directly; include <rtems/posix/pthread.h> instead."
cpukit/posix/inline/rtems/posix/semaphore.inl:18:# error "Never use <rtems/posix/semaphore.inl> directly; include <rtems/posix/semaphore.h> instead."
cpukit/posix/inline/rtems/posix/semaphore.inl:28:RTEMS_INLINE_ROUTINE POSIX_Semaphore_Control *_POSIX_Semaphore_Allocate( void )
cpukit/posix/inline/rtems/posix/mqueue.inl:18:# error "Never use <rtems/posix/mqueue.inl> directly; include <rtems/posix/mqueue.h> instead."
cpukit/posix/inline/rtems/posix/mqueue.inl:97:RTEMS_INLINE_ROUTINE POSIX_Message_queue_Control_fd *_POSIX_Message_queue_Get_fd (
cpukit/posix/inline/rtems/posix/mqueue.inl:124:RTEMS_INLINE_ROUTINE CORE_message_queue_Submit_types _POSIX_Message_queue_Priority_to_core(
cpukit/posix/inline/rtems/posix/mqueue.inl:156:  return _POSIX_Name_to_id( &_POSIX_Message_queue_Information, name, id, len );
cpukit/posix/inline/rtems/posix/key.inl:4: *  This include file contains the static inline implementation of the private 
cpukit/posix/inline/rtems/posix/key.inl:18:# error "Never use <rtems/posix/key.inl> directly; include <rtems/posix/key.h> instead."
cpukit/posix/inline/rtems/posix/priority.inl:4: * This defines the static inline methods related to POSIX priority management.
cpukit/posix/inline/rtems/posix/priority.inl:17:# error "Never use <rtems/posix/priority.inl> directly; include <rtems/posix/priority.h> instead."
cpukit/posix/inline/rtems/posix/spinlock.inl:18:# error "Never use <rtems/posix/spinlock.inl> directly; include <rtems/posix/spinlock.h> instead."
cpukit/posix/inline/rtems/posix/rwlock.inl:18:# error "Never use <rtems/posix/rwlock.inl> directly; include <rtems/posix/rwlock.h> instead."
cpukit/libblock/include/rtems/bdbuf.h:47: * devices and file systems.  The code provides read-ahead and write queuing to
cpukit/libblock/include/rtems/bdbuf.h:52: * size is called the media block size.  The file system can set the block size
cpukit/libblock/include/rtems/bdbuf.h:56: * The user configures the amount of memory to be used as buffers in the cache,
cpukit/libblock/include/rtems/bdbuf.h:57: * and the minimum and maximum buffer size.  The cache will allocate additional
cpukit/libblock/include/rtems/bdbuf.h:65: * that are a multiple of 2 of the minimum buffer size.  A group is the minimum
cpukit/libblock/include/rtems/bdbuf.h:66: * allocation unit for buffers of a specific size.  If a buffer of maximum size
cpukit/libblock/include/rtems/bdbuf.h:67: * is request the group will have a single buffer.  If a buffer of minimum size
cpukit/libblock/include/rtems/bdbuf.h:72: * realloced to a new size.  This is how buffers of different sizes move around
cpukit/libblock/include/rtems/bdbuf.h:75: * The buffers are held in various lists in the cache.  All buffers follow this
cpukit/libblock/include/rtems/bdbuf.h:95: *   legend_access [label="Access Wake-Up",fontcolor="royalblue",shape="none"];
cpukit/libblock/include/rtems/bdbuf.h:108: *   tp -> e [label="Transfer Done\nTransfer Error",color="red",fontcolor="red"];
cpukit/libblock/include/rtems/bdbuf.h:113: *   ac -> m [label="Release Modified",color="royalblue",fontcolor="royalblue"];
cpukit/libblock/include/rtems/bdbuf.h:117: *   am -> m [label="Release\nRelease Modified",color="royalblue",fontcolor="royalblue"];
cpukit/libblock/include/rtems/bdbuf.h:120: *   ae -> m [label="Release Modified",color="royalblue",fontcolor="royalblue"];
cpukit/libblock/include/rtems/bdbuf.h:124: *   ap -> e [label="Release\nRelease Modified\nSync",color="royalblue",fontcolor="royalblue"];
cpukit/libblock/include/rtems/bdbuf.h:134: * If the block is to be read by the user and not in the cache it is transfered
cpukit/libblock/include/rtems/bdbuf.h:168: * buffer is one that matches the same allocation size as the device the buffer
cpukit/libblock/include/rtems/bdbuf.h:173: * accessed buffers out of the cache when they should not.  The design should be
cpukit/libblock/include/rtems/bdbuf.h:302: * To manage buffers we using buffer descriptors (BD). A BD holds a buffer plus
cpukit/libblock/include/rtems/bdbuf.h:303: * a range of other information related to managing the buffer in the cache. To
cpukit/libblock/include/rtems/bdbuf.h:340: * maximum configured buffer size and is the allocation size for the buffers to
cpukit/libblock/include/rtems/bdbuf.h:347:  rtems_chain_node    link;          /**< Link the groups on a LRU list if they
cpukit/libblock/include/rtems/bdbuf.h:350:                                      * group. This value must be a multiple of
cpukit/libblock/include/rtems/bdbuf.h:357: * Buffering configuration definition. See confdefs.h for support on using this
cpukit/libblock/include/rtems/bdbuf.h:369:  uint32_t            swap_block_hold;         /**< Period a buffer is held. */
cpukit/libblock/include/rtems/bdbuf.h:375:  size_t              task_stack_size;         /**< Task stack size for swap-out
cpukit/libblock/include/rtems/bdbuf.h:458: * Prepare buffering layer to work - initialize buffer descritors and (if it is
cpukit/libblock/include/rtems/bdbuf.h:478: * buffer is not read from disk. This call is used when writing the whole block
cpukit/libblock/include/rtems/bdbuf.h:480: * available this call will block. A buffer obtained with this call will not be
cpukit/libblock/include/rtems/bdbuf.h:544: * modified call should be used. A buffer released with this call obtained by a
cpukit/libblock/include/rtems/bdbuf.h:589: * the disk by writing it. This buffer will be the first to be transfer to disk
cpukit/libblock/include/rtems/bdbuf.h:616: * @note Nesting calls to sync multiple devices will be handled sequentially. A
cpukit/libblock/include/rtems/bdbuf.h:633: * This may result in loss of data.  The read-ahead state of this device is reset.
cpukit/libblock/include/rtems/bdbuf.h:651: * loss of data.  After the synchronization the disk device is purged to ensure
cpukit/libblock/include/rtems/bdbuf.h:652: * a consistent cache state and the block size change occurs.  This also resets
cpukit/libblock/include/rtems/ide_part_table.h:17: *****************************************************************************/
cpukit/libblock/include/rtems/ide_part_table.h:124:    uint32_t            end; /* last partition sector, end = start + size - 1 */
cpukit/libblock/include/rtems/ide_part_table.h:131:    struct rtems_part_desc_s *sub_part[RTEMS_IDE_PARTITION_MAX_SUB_PARTITION_NUMBER];
cpukit/libblock/include/rtems/ide_part_table.h:166: * @deprecated Use the @ref rtems_bdpart "block device partition module" instead.
cpukit/libblock/include/rtems/ide_part_table.h:186: * @deprecated Use the @ref rtems_bdpart "block device partition module" instead.
cpukit/libblock/include/rtems/ide_part_table.h:205: * @deprecated Use the @ref rtems_bdpart "block device partition module" instead.
cpukit/libblock/include/rtems/ramdisk.h:54:   * @brief RAM disk location or @c NULL if RAM disk memory should be allocated
cpukit/libblock/include/rtems/ramdisk.h:153: * @a area_begin is @c NULL, the memory will be allocated and zeroed.  Sets the
cpukit/libblock/include/rtems/bdpart.h:57: * PC-compatible systems.  The GPT format is defined in the Extensible Firmware
cpukit/libblock/include/rtems/bdpart.h:60: * The most common task will be to read the partition information of a disk and
cpukit/libblock/include/rtems/bdpart.h:74: *  - <a href="http://en.wikipedia.org/wiki/UUID">Universally Unique Identifier</a>
cpukit/libblock/include/rtems/bdpart.h:75: *  - <a href="http://en.wikipedia.org/wiki/Globally_Unique_Identifier">Globally Unique Identifier</a>
cpukit/libblock/include/rtems/bdpart.h:76: *  - <a href="http://en.wikipedia.org/wiki/Disk_partitioning">Disk Paritioning</a>
cpukit/libblock/include/rtems/bdpart.h:77: *  - <a href="http://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</a>
cpukit/libblock/include/rtems/bdpart.h:78: *  - <a href="http://en.wikipedia.org/wiki/Master_boot_record">Master Boot Record</a>
cpukit/libblock/include/rtems/bdpart.h:79: *  - <a href="http://en.wikipedia.org/wiki/Extended_boot_record">Extended Boot Record</a>
cpukit/libblock/include/rtems/bdpart.h:80: *  - <a href="http://en.wikipedia.org/wiki/Cylinder-head-sector">Cylinder Head Sector</a>
cpukit/libblock/include/rtems/bdpart.h:81: *  - <a href="http://www.win.tue.nl/~aeb/partitions/partition_types-1.html">Partition Types</a>
cpukit/libblock/include/rtems/bdpart.h:129:   * Block index for partition end (this block is not a part of the partition).
cpukit/libblock/include/rtems/bdpart.h:313: * partition number equals the partition table index plus one.  The mount point
cpukit/libblock/include/rtems/bdpart.h:340:void rtems_bdpart_dump( const rtems_bdpart_partition *partitions, size_t count);
cpukit/libblock/include/rtems/flashdisk.h:342:  uint32_t                           segment_count; /**< Number of segments. */
cpukit/libblock/include/rtems/flashdisk.h:379:  uint32_t                       device_count;   /**< The number of devices. */
cpukit/libblock/include/rtems/flashdisk.h:380:  const rtems_fdisk_device_desc* devices;        /**< The device descriptions. */
cpukit/libblock/include/rtems/blkdev.h:36: * control. This call puts IO @ref rtems_blkdev_request "requests" to the block
cpukit/libblock/include/rtems/blkdev.h:46: * @warning The sync request is an IO one and only used from the cache. Use the
cpukit/libblock/include/rtems/blkdev.h:47: *          Block IO when operating at the device level. We need a sync request
cpukit/libblock/include/rtems/blkdev.h:96: * @ref RTEMS_BLKIO_REQUEST IO control.  The transfer request completion status
cpukit/libblock/include/rtems/blkdev.h:98: * called exactly once per request.  The return value of the IO control will be
cpukit/libblock/include/rtems/blkdev.h:293: * @param[in] media_block_size The media block size in bytes.  Must be positive.
cpukit/libblock/include/rtems/blkdev.h:295: * @param[in] handler The block device IO control handler.  Must not be @c NULL.
cpukit/libblock/include/rtems/blkdev.h:317: * A partition manages a subset of consecutive blocks contained in a parent block
cpukit/libblock/include/rtems/blkdev.h:377: * The device driver interface conventions suppose that a driver may contain an
cpukit/libblock/include/rtems/blkdev.h:379: * primitives (except initialize) can be implemented in a generic fashion based
cpukit/libblock/include/rtems/blkdev.h:380: * upon the supplied block device driver IO control handler. Every block device
cpukit/libblock/include/rtems/diskdevs.h:68:   * @brief Chain node for the read-ahead request queue of the read-ahead task.
cpukit/libblock/include/rtems/diskdevs.h:106:   * A read miss occurs in the rtems_bdbuf_read() function in case the block is
cpukit/libblock/include/rtems/diskdevs.h:166:   * @brief Physical device identifier (equals the @c dev entry if it specifies a
cpukit/libblock/include/rtems/diskdevs.h:236:   * calculated as media block = block << block_to_media_block_shift, otherwise
cpukit/libblock/include/rtems/diskdevs.h:261:   * @brief Indicates that this disk should be deleted as soon as the last user
cpukit/libblock/include/rtems/diskdevs.h:351: * @a block_count blocks.  The block index starts with zero.  The associated disk
cpukit/libblock/include/rtems/diskdevs.h:355: * block device driver during initialization when a physical device is detected
cpukit/libblock/include/rtems/diskdevs.h:380: * physical disk with identifier @a phys.  The start block index of the logical
cpukit/libblock/include/rtems/diskdevs.h:410: * that are marked as deleted and have a usage counter of zero will be deleted.
cpukit/libblock/include/rtems/diskdevs.h:412: * case of a physical disk deletion the IO control handler will be invoked with
cpukit/libblock/include/rtems/diskdevs.h:428: * @return Pointer to the disk device descriptor or @c NULL if no corresponding
cpukit/libblock/include/rtems/diskdevs.h:479: * Returns the next disk device descriptor with a device identifier larger than
cpukit/libblock/include/rtems/media.h:40: * actions.  For example a disk attach will lead to inspection of the partition
cpukit/libblock/include/rtems/media.h:127: *     <td>RTEMS_MEDIA_STATE_SUCCESS</td><td>driver name</td><td>disk path</td>
cpukit/libblock/include/rtems/media.h:480: * @brief Appends the @a minor number to the @a path resulting in "path-minor".
cpukit/libblock/include/rtems/nvdisk.h:153:  void*                               base;   /**< Base address of the device. */
cpukit/libblock/include/rtems/nvdisk.h:166:  const rtems_nvdisk_device_desc* devices;      /**< The device descriptions. */
cpukit/libblock/src/bdpart-register.c:84:    rv = snprintf( logical_disk_marker, RTEMS_BDPART_NUMBER_SIZE, "%zu", i + 1);
cpukit/libblock/src/ide_part_table.c:17: *****************************************************************************/
cpukit/libblock/src/ide_part_table.c:67:    s = (rtems_sector_data_t *) malloc(sizeof(rtems_sector_data_t) + RTEMS_IDE_SECTOR_SIZE);
cpukit/libblock/src/ide_part_table.c:298:            new_part_desc->end = new_part_desc->start + new_part_desc->size - 1;
cpukit/libblock/src/ide_part_table.c:576:    /* To avoid device numbers conflicts we have to use for logic disk the same
cpukit/libblock/src/ide_part_table.c:578:     * sum of logic disk partition number and the minor number of physical disk
cpukit/libblock/src/ide_part_table.c:599:            fprintf(stdout,"Cannot create device %s, error code %d\n", name, rc);
cpukit/libblock/src/media-desc.c:43:  [RTEMS_MEDIA_ERROR_DISK_OR_PARTITION_UNKNOWN] = "ERROR DISK OR PARTITION UNKNOWN",
cpukit/libblock/src/media-desc.c:44:  [RTEMS_MEDIA_ERROR_DISK_OR_PARTITION_EXISTS] = "ERROR DISK OR PARTITION EXISTS",
cpukit/libblock/src/media-desc.c:47:  [RTEMS_MEDIA_ERROR_PARTITION_DETACH_WITH_MOUNT] = "ERROR PARTITION DETACH WITH MOUNT",
cpukit/libblock/src/media-desc.c:48:  [RTEMS_MEDIA_ERROR_PARTITION_WITH_UNKNOWN_DISK] = "ERROR PARTITION WITH UNKNOWN DISK",
cpukit/libblock/src/bdpart-mount.c:69:  mount_point = malloc( mount_base_size + 1 + disk_file_name_size + RTEMS_BDPART_NUMBER_SIZE);
cpukit/libblock/src/bdpart-mount.c:76:  strncpy( mount_point + mount_base_size + 1, disk_file_name, disk_file_name_size);
cpukit/libblock/src/bdpart-mount.c:85:    int rv = snprintf( logical_disk_marker, RTEMS_BDPART_NUMBER_SIZE, "%zu", i + 1);
cpukit/libblock/src/bdpart-mount.c:146:  mount_point = malloc( mount_base_size + 1 + disk_file_name_size + RTEMS_BDPART_NUMBER_SIZE);
cpukit/libblock/src/bdpart-mount.c:153:  strncpy( mount_point + mount_base_size + 1, disk_file_name, disk_file_name_size);
cpukit/libblock/src/show_bdbuf.c:421:    printf("------------------------------------------------------------------------------\n");
cpukit/libblock/src/show_bdbuf.c:422:    printf(" pool #%03d: blksize=%5u nblks=%5u buf_mem=0x%08" PRIxPTR " bdbuf_mem=0x%08" PRIxPTR "\n",
cpukit/libblock/src/show_bdbuf.c:428:    printf("------------------------------------------------------------------------------\n");
cpukit/libblock/src/show_bdbuf.c:497: const show_bdbuf_bdbuf_info_t *bdbuf_info, /* struct to  store info of bdbuf */
cpukit/libblock/src/blkdev-imfs.c:163:     * It is not allowed to directly access the driver circumventing the cache.
cpukit/libblock/src/bdbuf.c:72:  rtems_id                     id;       /**< The id of the task so we can wake
cpukit/libblock/src/bdbuf.c:95:                                          * swap out task. It deletes itself. */
cpukit/libblock/src/bdbuf.c:105:                                          * buffer size that fit in a group. */
cpukit/libblock/src/bdbuf.c:117:  rtems_bdbuf_buffer* tree;              /**< Buffer descriptor lookup AVL tree
cpukit/libblock/src/bdbuf.c:299: * 5,704,880 and 4,294,967,295 nodes, depending on order of insertion.  You may
cpukit/libblock/src/bdbuf.c:821:     * Change the block number for the block size to the block number for the media
cpukit/libblock/src/bdbuf.c:937: * therefore know when we release the lock to the cache we will block until the
cpukit/libblock/src/bdbuf.c:960:   * The issue is a task could preempt after the cache is unlocked because it is
cpukit/libblock/src/bdbuf.c:961:   * blocking or just hits that window, and before this task has blocked on the
cpukit/libblock/src/bdbuf.c:962:   * semaphore. If the preempting task flushes the queue this task will not see
cpukit/libblock/src/bdbuf.c:963:   * the flush and may block for ever or until another transaction flushes this
cpukit/libblock/src/bdbuf.c:973:  sc = rtems_semaphore_obtain (waiters->sema, RTEMS_WAIT, RTEMS_BDBUF_WAIT_TIMEOUT);
cpukit/libblock/src/bdbuf.c:1176: * from the ALV tree and any lists then the new BD's are prepended to the ready
cpukit/libblock/src/bdbuf.c:1436:                      bdbuf_cache.buffer_min_count * bdbuf_config.buffer_min) != 0)
cpukit/libblock/src/bdbuf.c:1472:   * Create and start swapout task. This task will create and manage the worker
cpukit/libblock/src/bdbuf.c:1491:                                  RTEMS_BDBUF_READ_AHEAD_TASK_PRIORITY_DEFAULT,
cpukit/libblock/src/bdbuf.c:1622:           * It is essential that we wait here without a special wait count and
cpukit/libblock/src/bdbuf.c:1785:     * Compute the media block number. Drivers work with media block number not
cpukit/libblock/src/bdbuf.c:1869:rtems_bdbuf_transfer_done (rtems_blkdev_request* req, rtems_status_code status)
cpukit/libblock/src/bdbuf.c:2247:   * Take the sync lock before locking the cache. Once we have the sync lock we
cpukit/libblock/src/bdbuf.c:2248:   * can lock the cache. If another thread has the sync lock it will cause this
cpukit/libblock/src/bdbuf.c:2249:   * thread to block until it owns the sync lock then it can own the cache. The
cpukit/libblock/src/bdbuf.c:2256:   * Set the cache to have a sync active for a specific device and let the swap
cpukit/libblock/src/bdbuf.c:2330:        printf ("bdbuf:swapout write: bd:%" PRIu32 ", bufnum:%" PRIu32 " mode:%s\n",
cpukit/libblock/src/bdbuf.c:2377:      /* int result = */ dd->ioctl (dd->phys_dev, RTEMS_BLKDEV_REQ_SYNC, NULL);
cpukit/libblock/src/bdbuf.c:2388: * device is selected so select the device of the first buffer to be written to
cpukit/libblock/src/bdbuf.c:2506: * modified list extracting the buffers suitable to be written to disk. We have
cpukit/libblock/src/bdbuf.c:2533:   * syncing to release sync lock and currently worker threads do not return to
cpukit/libblock/src/bdbuf.c:2535:   * until after we have it running so we do not know to tell it to release the
cpukit/libblock/src/bdbuf.c:2633:   * I am disappointment at finding code like this in RTEMS. The request should
cpukit/libblock/src/bdbuf.c:2634:   * have been a rtems_chain_control. Simple, fast and less storage as the node
cpukit/libblock/src/bdbuf.c:2639:            (bdbuf_config.max_write_blocks * sizeof (rtems_blkdev_sg_buffer)));
cpukit/libblock/src/bdbuf.c:2673:    rtems_chain_append_unprotected (&bdbuf_cache.swapout_workers, &worker->link);
cpukit/libblock/src/bdbuf.c:2703:    rtems_chain_append_unprotected (&bdbuf_cache.swapout_workers, &worker->link);
cpukit/libblock/src/bdbuf.c:2712:                                  RTEMS_BDBUF_SWAPOUT_WORKER_TASK_PRIORITY_DEFAULT,
cpukit/libblock/src/bdpart-write.c:160:   * Set primary partition count.  If we have more than four partitions we need
cpukit/libblock/src/bdpart-write.c:161:   * an extended partition which will contain the partitions of number four and
cpukit/libblock/src/bdpart-write.c:178:   * four and above are logical partitions if we have more than four partitions
cpukit/libblock/src/bdpart-write.c:179:   * in total.  The logical partitions are contained in the extended partition.
cpukit/libblock/src/bdpart-write.c:182:   * compatibility resides between the partitions.  So there have to be gaps of
cpukit/libblock/src/bdpart-dump.c:45:    "-------------------------------------------------------------------------------\n"
cpukit/libblock/src/bdpart-dump.c:47:    "------------+------------+-----------------------------------------------------\n"
cpukit/libblock/src/bdpart-dump.c:49:    "------------+------------+-----------------------------------------------------\n"
cpukit/libblock/src/bdpart-dump.c:79:          snprintf( type_buffer, sizeof( type_buffer), "0x%02" PRIx8, type_mbr);
cpukit/libblock/src/bdpart-dump.c:96:  puts( "------------+------------+-----------------------------------------------------");
cpukit/libblock/src/media.c:302:        error(RTEMS_MEDIA_ERROR_PARTITION_ORPHAN, child->disk_path, disk_path);
cpukit/libblock/src/media.c:808:static rtems_status_code detach_item(rtems_media_event event, media_item *item)
cpukit/libblock/src/flashdisk.c:169:  uint32_t compact_segs;                   /**< Max segs to compact at once. */
cpukit/libblock/src/flashdisk.c:171:                                                compaction occurs when writing. */
cpukit/libblock/src/flashdisk.c:173:  uint32_t               block_size;       /**< The block size for this disk. */
cpukit/libblock/src/flashdisk.c:176:  uint32_t block_count;                    /**< The number of avail. blocks. */
cpukit/libblock/src/flashdisk.c:177:  uint32_t unavail_blocks;                 /**< The number of unavail blocks. */
cpukit/libblock/src/flashdisk.c:178:  uint32_t starvation_threshold;           /**< Erased blocks starvation threshold. */
cpukit/libblock/src/flashdisk.c:179:  uint32_t erased_blocks;                  /**< The number of erased blocks. */
cpukit/libblock/src/flashdisk.c:183:  uint32_t                device_count;    /**< The number of flash devices. */
cpukit/libblock/src/flashdisk.c:191:  rtems_fdisk_segment_ctl_queue failed;    /**< The list of segments that failed
cpukit/libblock/src/flashdisk.c:193:  rtems_id lock;                           /**< Mutex for threading protection.*/
cpukit/libblock/src/flashdisk.c:195:  uint8_t* copy_buffer;                    /**< Copy buf used during compacting */
cpukit/libblock/src/flashdisk.c:199:  uint32_t starvations;                    /**< Erased blocks starvations counter. */
cpukit/libblock/src/flashdisk.c:224:  rtems_fdisk_crc16_factor[((_b) ^ ((_c) & 0xff)) & 0xff] ^ (((_c) >> 8) & 0xff)
cpukit/libblock/src/flashdisk.c:584:  queues[0] = rtems_fdisk_segment_queue_present (&fd->available, sc) ? 'A' : '-';
cpukit/libblock/src/flashdisk.c:585:  queues[1] = rtems_fdisk_segment_queue_present (&fd->used, sc)      ? 'U' : '-';
cpukit/libblock/src/flashdisk.c:586:  queues[2] = rtems_fdisk_segment_queue_present (&fd->erase, sc)     ? 'E' : '-';
cpukit/libblock/src/flashdisk.c:587:  queues[3] = rtems_fdisk_segment_queue_present (&fd->failed, sc)    ? 'F' : '-';
cpukit/libblock/src/flashdisk.c:911:                                page * fd->block_size, buffer, fd->block_size);
cpukit/libblock/src/flashdisk.c:925:                                 page * fd->block_size, buffer, fd->block_size);
cpukit/libblock/src/flashdisk.c:1145:                    sc->pages, sc->pages_active, sc->pages_used, sc->pages_bad,
cpukit/libblock/src/flashdisk.c:1555:      rtems_fdisk_segment_ctl*        sc = &fd->devices[device].segments[segment];
cpukit/libblock/src/flashdisk.c:1562:      rtems_fdisk_info (fd, "recover-block-mappings:%02d-%03d", device, segment);
cpukit/libblock/src/flashdisk.c:1652:          else if (rtems_fdisk_page_desc_flags_set (pd, RTEMS_FDISK_PAGE_ACTIVE))
cpukit/libblock/src/flashdisk.c:1658:                                   "invalid block number: %d-%d-%d: block: %d",
cpukit/libblock/src/flashdisk.c:1669:               * duplicates appear. A power down with a failed wirte could cause
cpukit/libblock/src/flashdisk.c:1672:              const rtems_fdisk_segment_ctl* bsc = fd->blocks[pd->block].segment;
cpukit/libblock/src/flashdisk.c:1763:                    sc->pages, sc->pages_active, sc->pages_used, sc->pages_bad,
cpukit/libblock/src/flashdisk.c:1785:                          "read-block:%02d-%03d-%03d: read page failed: %s (%d)",
cpukit/libblock/src/flashdisk.c:1802:      rtems_fdisk_error ("read-block: block points to used page: %d: %d-%d-%d",
cpukit/libblock/src/flashdisk.c:2014:      ret = rtems_fdisk_seg_write_page (fd, sc, page + sc->pages_desc, buffer);
cpukit/libblock/src/flashdisk.c:2018:        rtems_fdisk_info (fd, "write-block:%02d-%03d-%03d: write page failed: " \
cpukit/libblock/src/flashdisk.c:2232:                      "Flash Disk Driver Status : %d.%d", fd->major, fd->minor);
cpukit/libblock/src/flashdisk.c:2236:  rtems_fdisk_printf (fd, "Starvation threshold\t%d", fd->starvation_threshold);
cpukit/libblock/src/flashdisk.c:2241:                      count, rtems_fdisk_segment_queue_count (&fd->available));
cpukit/libblock/src/flashdisk.c:2307:                                "    %ld\t not active when mapped by block %ld",
cpukit/libblock/src/flashdisk.c:2415:                                             (rtems_fdisk_monitor_data*) argp);
cpukit/libblock/src/flashdisk.c:2548:                                             sizeof (rtems_fdisk_segment_ctl));
cpukit/libblock/src/blkdev-print-stats.c:31:     "-------------------------------------------------------------------------------\n"
cpukit/libblock/src/blkdev-print-stats.c:33:     "----------------------+--------------------------------------------------------\n"
cpukit/libblock/src/blkdev-print-stats.c:42:     "----------------------+--------------------------------------------------------\n",
cpukit/libblock/src/ramdisk-driver.c:64:        rtems_ramdisk_printf (rd, "ramdisk read: buf=%d block=%d length=%d off=%d addr=%p",
cpukit/libblock/src/ramdisk-driver.c:65:                              i, sg->block, sg->length, sg->block * rd->block_size,
cpukit/libblock/src/ramdisk-driver.c:88:        rtems_ramdisk_printf (rd, "ramdisk write: buf=%d block=%d length=%d off=%d addr=%p",
cpukit/libblock/src/ramdisk-driver.c:89:                              i, sg->block, sg->length, sg->block * rd->block_size,
cpukit/libblock/src/nvdisk.c:95:  uint32_t                  block_size;   /**< The block size for this disk. */
cpukit/libblock/src/nvdisk.c:96:  uint32_t                  block_count;  /**< The number of available blocks. */
cpukit/libblock/src/nvdisk.c:97:  rtems_nvdisk_device_ctl*  devices;      /**< The NV devices for this disk. */
cpukit/libblock/src/nvdisk.c:99:  uint32_t                  cs_pages;     /**< The num of pages of checksums. */
cpukit/libblock/src/nvdisk.c:100:  rtems_id                  lock;         /**< Mutex for threading protection.*/
cpukit/libblock/src/nvdisk.c:126:  rtems_nvdisk_crc16_factor[((_b) ^ ((_c) & 0xff)) & 0xff] ^ (((_c) >> 8) & 0xff)
cpukit/libblock/src/nvdisk.c:507:  ret = rtems_nvdisk_read_page (nvd, dc->device, page + dc->pages_desc, buffer);
cpukit/libblock/src/nvdisk.c:555:  rtems_nvdisk_info (nvd, " write-block:%d=>%02d-%03d", block, dc->device, page);
cpukit/libblock/src/nvdisk.c:558:  ret = rtems_nvdisk_write_page (nvd, dc->device, page + dc->pages_desc, buffer);
cpukit/libblock/src/nvdisk.c:808:      dc->pages      = rtems_nvdisk_pages_in_device (nvd, &c->devices[device]);
cpukit/libblock/src/nvdisk.c:809:      dc->pages_desc = rtems_nvdisk_page_desc_pages (nvd, &c->devices[device]);
cpukit/ftpd/ftpd.c:36: *      * `command_pasv()' changed to set timeout on socket we are listening on
cpukit/ftpd/ftpd.c:269:  bool                auth;        /* true if user/pass was valid, false if not or not supplied */
cpukit/ftpd/ftpd.c:1435:  if (info->xfer_mode != TYPE_I || 0 > stat(fname, &stbuf) || stbuf.st_size < 0)
cpukit/ftpd/ftpd.c:1558:      snprintf(buf, FTPD_BUFSIZE, "Entering passive mode (%u,%u,%u,%u,%u,%u).",
cpukit/ftpd/ftpd.c:1823:        if((c != NULL) && (sscanf(args, "%o", &mask) == 1) && strncpy(fname, c+1, 254) 
cpukit/ftpd/ftpd.c:1891: * This task handles single session.  It is waked up when the FTP daemon gets a
cpukit/ftpd/ftpd.h:20:  FTPD_STACKSIZE = RTEMS_MINIMUM_STACK_SIZE + FTPD_DATASIZE /* Tasks stack size */
cpukit/libfs/src/imfs/imfs_fifo.c:19:#define LIBIO2PIPE(_iop)  ( JNODE2PIPE((IMFS_jnode_t *)(_iop)->pathinfo.node_access) )
cpukit/libfs/src/imfs/memfile.c:245:  offset = the_jnode->info.file.size - old_blocks * IMFS_MEMFILE_BYTES_PER_BLOCK;
cpukit/libfs/src/imfs/imfs_directory.c:69:   /* The directory was not empty so try to move to the desired entry in chain*/
cpukit/libfs/src/imfs/imfs_debug.c:137:  fprintf(stdout, "***************      End of Dump       ***************\n" );
cpukit/libfs/src/imfs/imfs_fchmod.c:44:  jnode->st_mode &= ~(S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID | S_ISGID | S_ISVTX);
cpukit/libfs/src/imfs/imfs_fchmod.c:45:  jnode->st_mode |= mode & (S_IRWXU | S_IRWXG | S_IRWXO | S_ISUID | S_ISGID | S_ISVTX);
cpukit/libfs/src/imfs/imfs_stat.c:36:    rtems_filesystem_make_dev_t( IMFS_DEVICE_MAJOR_NUMBER, fs_info->instance );
cpukit/libfs/src/pipe/pipe.h:36:  unsigned int writerCounter;     /* for differentiation of successive opens */
cpukit/libfs/src/rfs/rtems-rfs-mutex.h:15: * It may be suprising we abstract this for the RTEMS file system but this code
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:59:   * system. All directory entries are links to an inode. A link such as a HARD
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:142:  bool access_ok = rtems_rfs_rtems_eval_perms (ctx, RTEMS_FS_PERMS_EXEC, inode);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:268:    printf ("rtems-rfs-rtems: link: in: parent:%" PRId32 " target:%" PRId32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:282: * The following verifies that and returns the type of node that the loc refers
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:293:  rtems_rfs_ino                 ino = rtems_rfs_rtems_get_pathloc_ino (pathloc);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:412: * The following routine creates a new symbolic link node under parent with the
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:419:                         size_t                                  node_name_len,
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:423:  rtems_rfs_ino          parent = rtems_rfs_rtems_get_pathloc_ino (parent_loc);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:477:    printf ("rtems-rfs-rtems: fchmod: in: ino:%" PRId32 " mode:%06" PRIomode_t "\n",
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:605:  rtems_rfs_ino           parent = rtems_rfs_rtems_get_pathloc_ino (parentloc);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:672:  rtems_rfs_ino          parent = rtems_rfs_rtems_get_pathloc_ino (parent_pathloc);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:678:    printf ("rtems-rfs: rmnod: parent:%" PRId32 " doff:%" PRIu32 ", ino:%" PRId32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:681:  rc = rtems_rfs_unlink (fs, parent, ino, doff, rtems_rfs_unlink_dir_if_empty);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:733:    printf ("rtems-rfs: rename: ino:%" PRId32 " doff:%" PRIu32 ", new parent:%" PRId32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:814:int rtems_rfs_rtems_initialise (rtems_filesystem_mount_table_entry_t *mt_entry,
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:816:void rtems_rfs_rtems_shutdown (rtems_filesystem_mount_table_entry_t *mt_entry);
cpukit/libfs/src/rfs/rtems-rfs-rtems.c:908:    return rtems_rfs_rtems_error ("initialise: cannot lock access  mutex", rc);
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:47:  -------------------------------------------------------------------------------
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:54:  reverse, there are at least 32 bits of the output that are sometimes the same
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:57:  * pairs that differed by one bit, by two bits, in any combination of top bits
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:67:  Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that satisfy this
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:74:  Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing for "differ" defined
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:88:  -------------------------------------------------------------------------------
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:101:  -------------------------------------------------------------------------------
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:107:  * pairs that differed by one bit, by two bits, in any combination of top bits
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:123:  -------------------------------------------------------------------------------
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:158: *  If you are hashing n strings (uint8_t **)k, do it like this: for (i=0, h=0;
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:173:  union { const void *ptr; size_t i; } u;     /* needed for Mac Powerbook G4 */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:180:    const uint32_t *k = (const uint32_t *)key;         /* read 32-bit chunks */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:183:    /*------ all but last block: aligned reads and affect 32 bits of (a,b,c) */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:194:    /*----------------------------- handle the last (probably partial) block */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:220:      case 0 : return c;              /* zero length strings require no mixing */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:246:    const uint16_t *k = (const uint16_t *)key;         /* read 16-bit chunks */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:249:    /*--------------- all but last block: aligned reads and different mixing */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:260:    /*----------------------------- handle the last (probably partial) block */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:289:      case 0 : return c;                     /* zero length requires no mixing */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:292:  } else {                        /* need to read the key one byte at a time */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:295:    /*--------------- all but the last block: affect some 32 bits of (a,b,c) */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:315:    /*-------------------------------- last block: affect all 32 bits of (c) */
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.c:316:    switch(length)                   /* all the case statements fall through */
cpukit/libfs/src/rfs/rtems-rfs-link.c:15: * These functions manage links. A link is the addition of a directory entry in
cpukit/libfs/src/rfs/rtems-rfs-link.c:121:    printf ("rtems-rfs: unlink: parent(%" PRIu32 ") -X-> (%" PRIu32 ")\n", parent, target);
cpukit/libfs/src/rfs/rtems-rfs-link.c:182:    printf ("rtems-rfs: unlink: target:%" PRIu32 " links:%u\n", target, links);
cpukit/libfs/src/rfs/rtems-rfs-link.c:284:   * place the link into the data area else allocate a block and write the link
cpukit/libfs/src/rfs/rtems-rfs-block.c:17: * set when the file system is set up and needs to be matched for it to be read
cpukit/libfs/src/rfs/rtems-rfs-block.c:29: * block in the group. When a file system is mounted the block bitmaps are read
cpukit/libfs/src/rfs/rtems-rfs-block.c:103:   * do not unload it. The caller may assume it is still loaded when we return.
cpukit/libfs/src/rfs/rtems-rfs-block.c:192: * @param offset The offset in the table of the block number to return. This is
cpukit/libfs/src/rfs/rtems-rfs-block.c:207:   * If the handle has a buffer and this request is a different block the current
cpukit/libfs/src/rfs/rtems-rfs-block.c:222:              " block=%" PRId32 ", indirect=%" PRId32 "/%d\n", *result, block, offset);
cpukit/libfs/src/rfs/rtems-rfs-block.c:247:   * If the block position is the same and we have found the block just return it.
cpukit/libfs/src/rfs/rtems-rfs-block.c:256:     * Determine the type of access we need to perform. If the number of blocks
cpukit/libfs/src/rfs/rtems-rfs-block.c:257:     * is less than or equal to the number of slots in the inode the blocks are
cpukit/libfs/src/rfs/rtems-rfs-block.c:278:         * This is a single indirect table of blocks anchored off a slot in the
cpukit/libfs/src/rfs/rtems-rfs-block.c:312:           * This should never happen. Here so Joel can remove once his coverage
cpukit/libfs/src/rfs/rtems-rfs-block.c:377:  rc = rtems_rfs_group_bitmap_alloc (fs, map->last_map_block, false, &new_block);
cpukit/libfs/src/rfs/rtems-rfs-block.c:412:    printf ("rtems-rfs: block-map-grow: entry: blocks=%zd count=%" PRIu32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-block.c:442:       * Single indirect access is occuring. It could still be doubly indirect.
cpukit/libfs/src/rfs/rtems-rfs-block.c:454:         * mapping table if direct is 0 or we are moving up (upping). If upping
cpukit/libfs/src/rfs/rtems-rfs-block.c:496:         * it is the first entry of a new block. We may also need to allocate a
cpukit/libfs/src/rfs/rtems-rfs-block.c:513:           * Allocate a new block for a doubly indirect table if singly is 0 as
cpukit/libfs/src/rfs/rtems-rfs-block.c:608:   * If this is the first block in the indirect table (index == 0), ie the last
cpukit/libfs/src/rfs/rtems-rfs-block.c:609:   * block to be freed and the indirect block is now also free, or we have only
cpukit/libfs/src/rfs/rtems-rfs-block.c:652:    printf ("rtems-rfs: block-map-shrink: entry: blocks=%zd count=%" PRIu32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-block.c:681:       * Single indirect access is occuring. It could still be doubly indirect.
cpukit/libfs/src/rfs/rtems-rfs-block.c:696:         * Request the indirect block and then obtain the block number from the
cpukit/libfs/src/rfs/rtems-rfs-block.c:707:        rc = rtems_rfs_block_map_indirect_shrink (fs, map, &map->singly_buffer,
cpukit/libfs/src/rfs/rtems-rfs-block.c:718:         * into the doubly indirect table pointing to the singly indirect table
cpukit/libfs/src/rfs/rtems-rfs-block.c:720:         * if the current doubly indirect table needs to be freed. The 'direct'
cpukit/libfs/src/rfs/rtems-rfs-block.c:756:          rc = rtems_rfs_block_map_indirect_shrink (fs, map, &map->doubly_buffer,
cpukit/libfs/src/rfs/rtems-rfs-rtems-dev.c:52:  rtems_rfs_file_system*        fs = rtems_rfs_rtems_pathloc_dev (&iop->pathinfo);
cpukit/libfs/src/rfs/rtems-rfs-dir-hash.h:13: * RTEMS File Systems Directory Hash provides a 32bit hash of a string. This is
cpukit/libfs/src/rfs/rtems-rfs-inode.c:209:    printf (" type:%s mode:%04x (%03o)\n", type, mode, mode & ((1 << 10) - 1));
cpukit/libfs/src/rfs/rtems-rfs-block-pos.h:15: * These functions manage the position in a block map as well as a size of data
cpukit/libfs/src/rfs/rtems-rfs-block-pos.h:18: * of a map. The size has a block count plus an offset, but the offset into the
cpukit/libfs/src/rfs/rtems-rfs-block-pos.h:33: * The block number is the same type as the inode block number. This makes sure
cpukit/libfs/src/rfs/rtems-rfs-block-pos.h:44: * A block position is a block number times the block size plus the offset. The
cpukit/libfs/src/rfs/rtems-rfs-block-pos.h:167:  ((((_p)->bno == 0) && ((_s)->count == 0)) || ((_p)->bno == ((_s)->count - 1)))
cpukit/libfs/src/rfs/rtems-rfs-data.h:15: * Access data in the correct byte order for the specific target we are running
cpukit/libfs/src/rfs/rtems-rfs-file.h:29: * File data that is shared by various file handles accessing the same file. We
cpukit/libfs/src/rfs/rtems-rfs-file.h:169:#define RTEMS_RFS_FILE_NO_LENGTH_UPDATE (1 << 2) /**< Do not update the position
cpukit/libfs/src/rfs/rtems-rfs-file.h:254: * Update the modified time field of the inode when writing if flagged to do so.
cpukit/libfs/src/rfs/rtems-rfs-file.h:323: * @param read The I/O operation is a read so the block is read from the media.
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.c:426:        test_bit = (map_index * rtems_rfs_bitmap_element_bits ()) + map_offset;
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.c:444:       * Align test_bit either up or down depending on the direction to next 32
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.c:462:        test_bit -= ((bits_skipped - 1) * rtems_rfs_bitmap_element_bits ()) + 1;
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.c:501:   * Start from the seed and move in either direction. Search in window amounts
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.c:631:  control->search_bits = malloc (elements * sizeof (rtems_rfs_bitmap_element));
cpukit/libfs/src/rfs/rtems-rfs-format.h:82:int rtems_rfs_format (const char* name, const rtems_rfs_format_config* config);
cpukit/libfs/src/rfs/rtems-rfs-rtems-file.c:56:    printf("rtems-rfs: file-open: path:%s ino:%" PRId32 " flags:%04i mode:%04" PRIu32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-rtems-file.c:282:    printf("rtems-rfs: file-lseek: handle:%p offset:%" PRIdoff_t "\n", file, offset);
cpukit/libfs/src/rfs/rtems-rfs-rtems-file.c:321:    printf("rtems-rfs: file-ftrunc: handle:%p length:%" PRIdoff_t "\n", file, length);
cpukit/libfs/src/rfs/rtems-rfs-dir.h:107: * Look up a directory entry in the directory pointed to by the inode. The look
cpukit/libfs/src/rfs/rtems-rfs-inode.h:69:  RTEMS_RFS_S_IFLNK | RTEMS_RFS_S_IRWXU | RTEMS_RFS_S_IRWXG | RTEMS_RFS_S_IRWXO
cpukit/libfs/src/rfs/rtems-rfs-inode.h:157:   * The last block map block. Used as the goal when allocating a new block for
cpukit/libfs/src/rfs/rtems-rfs-inode.h:389:rtems_rfs_inode_set_block_count (rtems_rfs_inode_handle* handle, uint32_t block_count)
cpukit/libfs/src/rfs/rtems-rfs-inode.h:494:rtems_rfs_inode_set_block (rtems_rfs_inode_handle* handle, int block, uint32_t bno)
cpukit/libfs/src/rfs/rtems-rfs-inode.h:519:rtems_rfs_inode_set_last_map_block (rtems_rfs_inode_handle* handle, uint32_t last_map_block)
cpukit/libfs/src/rfs/rtems-rfs-inode.h:544:rtems_rfs_inode_set_last_data_block (rtems_rfs_inode_handle* handle, uint32_t last_data_block)
cpukit/libfs/src/rfs/rtems-rfs-inode.h:639: * Delete the inode eraseing it and release the buffer to commit the write. You
cpukit/libfs/src/rfs/rtems-rfs-inode.h:684: * @return rtems_rfs_pos The data size in bytes in the block map attched to the
cpukit/libfs/src/rfs/rtems-rfs.h:26:int rtems_rfs_rtems_initialise (rtems_filesystem_mount_table_entry_t *mt_entry);
cpukit/libfs/src/rfs/rtems-rfs-shell.c:40:typedef int (*rtems_rfs_shell_handler) (rtems_rfs_file_system* fs, int argc, char *argv[]);
cpukit/libfs/src/rfs/rtems-rfs-shell.c:75: * Get the file system data from the specific path. Checks to make sure the path is
cpukit/libfs/src/rfs/rtems-rfs-shell.c:130:  printf ("        block size: %zu\n",           rtems_rfs_fs_block_size (fs));
cpukit/libfs/src/rfs/rtems-rfs-shell.c:132:  printf ("  media block size: %" PRIu32 "\n",   rtems_rfs_fs_media_block_size (fs));
cpukit/libfs/src/rfs/rtems-rfs-shell.c:133:  printf ("        media size: %" PRIu64 "\n",   rtems_rfs_fs_media_size (fs));
cpukit/libfs/src/rfs/rtems-rfs-shell.c:393:          printf ("links=%03i mode=%04x (%s/%03o) bo=%04u bc=%04" PRIu32 " b=[",
cpukit/libfs/src/rfs/rtems-rfs-shell.c:497:      printf (" %5d: entry ino appears corrupt: ino=%" PRId32 "\n", entry, eino);
cpukit/libfs/src/rfs/rtems-rfs-shell.c:578:    inodes = fs->group_inodes - rtems_rfs_bitmap_map_free (&group->inode_bitmap);
cpukit/libfs/src/rfs/rtems-rfs-shell.c:579:    printf (" %4d: base=%-7" PRIu32 " size=%-6zu blocks=%-5zu (%3zu%%) inode=%-5zu (%3zu%%)\n",
cpukit/libfs/src/rfs/rtems-rfs-shell.c:615:      "Display the group data of a file system, group, group <group>, group <start> <end>" },
cpukit/libfs/src/rfs/rtems-rfs-shell.c:635:        for (t = 0; t < (sizeof (table) / sizeof (const rtems_rfs_shell_cmd)); t++)
cpukit/libfs/src/rfs/rtems-rfs-shell.c:645:    printf ("error: you need at least a path and command, try %s -h\n", argv[0]);
cpukit/libfs/src/rfs/rtems-rfs-shell.c:651:      for (t = 0; t < (sizeof (table) / sizeof (const rtems_rfs_shell_cmd)); t++)
cpukit/libfs/src/rfs/rtems-rfs-buffer.c:48:    printf ("rtems-rfs: buffer-scan: count=%" PRIu32 ", block=%" PRIu32 ": ", *count, block);
cpukit/libfs/src/rfs/rtems-rfs-buffer.c:172:        printf ("rtems-rfs: buffer-request: block=%" PRIu32 ": bdbuf-%s: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-buffer.c:191:    printf ("rtems-rfs: buffer-request: block=%" PRIu32 " bdbuf-%s=%" PRIu32 " refs=%d\n",
cpukit/libfs/src/rfs/rtems-rfs-buffer.c:246:                    " %" PRIu32 "\n", fs->release_count + fs->release_modified_count);
cpukit/libfs/src/rfs/rtems-rfs-buffer.c:338:    printf ("rtems-rfs: buffer-open: blks=%" PRId32 ", blk-size=%" PRId32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-trace.h:83: * Call to check if this part is bring traced. If RTEMS_RFS_TRACE is defined to
cpukit/libfs/src/rfs/rtems-rfs-format.c:59: * Return the number of inodes as a percentage of the total number that can fit
cpukit/libfs/src/rfs/rtems-rfs-format.c:120:    printf ("block size (%zd) is not a multiple of media block size (%" PRId32 ")\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:240:                              group_base + RTEMS_RFS_GROUP_BLOCK_BITMAP_BLOCK);
cpukit/libfs/src/rfs/rtems-rfs-format.c:244:    printf ("\nrtems-rfs: write-group: group %3d: open block bitmap failed: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:253:  memset (rtems_rfs_buffer_data (&handle), 0xff, rtems_rfs_fs_block_size (fs));
cpukit/libfs/src/rfs/rtems-rfs-format.c:263:    printf ("\nrtems-rfs: write-group: group %3d: block bitmap clear all failed: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:296:    printf ("\nrtems-rfs: write-group: group %3d: close block bitmap failed: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:310:                              group_base + RTEMS_RFS_GROUP_INODE_BITMAP_BLOCK);
cpukit/libfs/src/rfs/rtems-rfs-format.c:314:    printf ("\nrtems-rfs: write-group: group %3d: open inode bitmap failed: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:323:  memset (rtems_rfs_buffer_data (&handle), 0x00, rtems_rfs_fs_block_size (fs));
cpukit/libfs/src/rfs/rtems-rfs-format.c:360:                                            group_base + b + RTEMS_RFS_GROUP_INODE_BLOCK,
cpukit/libfs/src/rfs/rtems-rfs-format.c:365:        printf ("\nrtems-rfs: write-group: group %3d: block %" PRId32 " request failed: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:372:       * Force the whole buffer to a known state. The bit map may not occupy the
cpukit/libfs/src/rfs/rtems-rfs-format.c:375:      memset (rtems_rfs_buffer_data (&handle), 0xff, rtems_rfs_fs_block_size (fs));
cpukit/libfs/src/rfs/rtems-rfs-format.c:447:    printf ("rtems-rfs: write-superblock: buffer handle close failed: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-format.c:467:                          RTEMS_RFS_FS_FORCE_OPEN | RTEMS_RFS_FS_NO_LOCAL_CACHE,
cpukit/libfs/src/rfs/rtems-rfs-format.c:487:    printf ("rtems-rfs: format: allocated inode not root ino: %" PRId32 "\n", ino);
cpukit/libfs/src/rfs/rtems-rfs-block.h:58: * The blocks cannot have all ones as a block number nor block 0. The block map
cpukit/libfs/src/rfs/rtems-rfs-block.h:66: * Direct access has the blocks numbers in the inode slots. The Single Indirect
cpukit/libfs/src/rfs/rtems-rfs-block.h:67: * Access has block numbers in the inode slots that pointer to a table of block
cpukit/libfs/src/rfs/rtems-rfs-block.h:74: * Double occurs when the map block count is greated than the block numbers per
cpukit/libfs/src/rfs/rtems-rfs-dir.c:51:  (((_l) <= RTEMS_RFS_DIR_ENTRY_SIZE) || ((_l) >= rtems_rfs_fs_max_name (_f)) \
cpukit/libfs/src/rfs/rtems-rfs-dir.c:83:      printf ("rtems-rfs: dir-lookup-ino: map open failed for ino %" PRIu32 ": %d: %s",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:92:      printf ("rtems-rfs: dir-lookup-ino: handle open failed for ino %" PRIu32 ": %d: %s",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:129:        printf ("rtems-rfs: dir-lookup-ino: block read, ino=%" PRIu32 " bno=%" PRId32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:136:          printf ("rtems-rfs: dir-lookup-ino: block read, ino=%" PRIu32 " block=%" PRId32 ": %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:150:      while (map.bpos.boff < (rtems_rfs_fs_block_size (fs) - RTEMS_RFS_DIR_ENTRY_SIZE))
cpukit/libfs/src/rfs/rtems-rfs-dir.c:166:                    "bad length or ino for ino %" PRIu32 ": %u/%" PRId32 " @ %04" PRIx32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:167:                    rtems_rfs_inode_ino (inode), elength, *ino, map.bpos.boff);
cpukit/libfs/src/rfs/rtems-rfs-dir.c:176:                    "checking entry for ino %" PRId32 ": bno=%04" PRIx32 "/off=%04" PRIx32
cpukit/libfs/src/rfs/rtems-rfs-dir.c:187:                      "entry found in ino %" PRIu32 ", ino=%" PRIu32 " offset=%" PRIu32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:207:                    "block map next block failed in ino %" PRIu32 ": %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:219:        printf ("rtems-rfs: dir-lookup-ino: block is 0 in ino %" PRIu32 ": %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:276:     * empty which happens when creating a directory and adding the first entry
cpukit/libfs/src/rfs/rtems-rfs-dir.c:359:                  "bad length or ino for ino %" PRIu32 ": %u/%" PRId32 " @ %04x\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:389:    printf ("rtems-rfs: dir-del-entry: dir=%" PRId32 ", entry=%" PRId32 " offset=%" PRIu32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:433:     * If we are searching start at the beginning of the block. If not searching
cpukit/libfs/src/rfs/rtems-rfs-dir.c:443:    while (eoffset < (rtems_rfs_fs_block_size (fs) - RTEMS_RFS_DIR_ENTRY_SIZE))
cpukit/libfs/src/rfs/rtems-rfs-dir.c:476:         * @note We could check again to see if the new end block in the map is
cpukit/libfs/src/rfs/rtems-rfs-dir.c:483:                  "last block free for ino %" PRIu32 ": elength=%i block=%" PRIu32
cpukit/libfs/src/rfs/rtems-rfs-dir.c:604:                  "bad length or ino for ino %" PRIu32 ": %u/%" PRId32 " @ %04" PRIx32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:631:        printf ("rtems-rfs: dir-read: found off:%" PRIooff_t " ino:%ld name=%s\n",
cpukit/libfs/src/rfs/rtems-rfs-dir.c:663:    printf ("rtems-rfs: dir-empty: dir=%" PRId32 "\n", rtems_rfs_inode_ino (dir));
cpukit/libfs/src/rfs/rtems-rfs-dir.c:716:                  "bad length or ino for ino %" PRIu32 ": %u/%" PRIu32 " @ %04x\n",
cpukit/libfs/src/rfs/rtems-rfs-rtems.h:26: * RTEMS RFS RTEMS Error Enable. Set to 1 for printing of errors. Default is off.
cpukit/libfs/src/rfs/rtems-rfs-rtems.h:31: * RTEMS RFS RTEMS Trace Enable. Set to 1 for printing of errors. Default is off.
cpukit/libfs/src/rfs/rtems-rfs-rtems.h:36: * If we are not handling errors provide a define that removes the strings from
cpukit/libfs/src/rfs/rtems-rfs-rtems.h:57: * development tool where can edit the values below to control the various trace
cpukit/libfs/src/rfs/rtems-rfs-rtems.h:229: * @param inode The inode handle to check the mode of for the type of handlers.
cpukit/libfs/src/rfs/rtems-rfs-rtems.h:293:int rtems_rfs_rtems_rmnod (const rtems_filesystem_location_info_t* parent_pathloc,
cpukit/libfs/src/rfs/rtems-rfs-link.h:56: * Unlink the node from the parent directory. A directory offset for the target
cpukit/libfs/src/rfs/rtems-rfs-link.h:57: * entry is required because links cause a number of inode numbers to appear in
cpukit/libfs/src/rfs/rtems-rfs-file.c:183:        printf ("rtems-rfs: file-close: map close error: ino=%" PRId32 ": %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-file.c:193:        printf ("rtems-rfs: file-close: inode close error: ino=%" PRId32 ": %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-file.c:275:           (*available < rtems_rfs_fs_block_size (rtems_rfs_file_fs (handle)))))
cpukit/libfs/src/rfs/rtems-rfs-file.c:280:      printf ("rtems-rfs: file-io: start: block=%" PRIu32 " request-read=%s\n",
cpukit/libfs/src/rfs/rtems-rfs-file.c:338:   * so no special maths is needed. If the offset is bigger than the block size
cpukit/libfs/src/rfs/rtems-rfs-file.c:371:    printf ("rtems-rfs: file-io:   end: pos=%" PRIu32 ":%" PRIu32 " %c %c %c\n",
cpukit/libfs/src/rfs/rtems-rfs-file.c:413:   * This call only sets the position if it is in a valid part of the file. The
cpukit/libfs/src/rfs/rtems-rfs-file.c:456:     * The seek is outside the current file so release any buffer. A write will
cpukit/libfs/src/rfs/rtems-rfs-file.c:520:           * the map. If not found and the EOF grow the map then fill the block
cpukit/libfs/src/rfs/rtems-rfs-file.c:523:          rtems_rfs_block_size_get_bpos (rtems_rfs_block_map_size (map), &bpos);
cpukit/libfs/src/rfs/rtems-rfs-file.c:555:                                                rtems_rfs_file_buffer (handle),
cpukit/libfs/src/rfs/rtems-rfs-file.c:566:                                                rtems_rfs_file_buffer (handle));
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:29: * Define the way the bits are configured. We can have them configured as clear
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:30: * being 0 or clear being 1. This does not effect how masks are defined. A mask
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:41:#define RTEMS_RFS_BITMAP_ELEMENT_SET        (RTEMS_RFS_BITMAP_ELEMENT_FULL_MASK)
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:45:#define RTEMS_RFS_BITMAP_TEST_BIT(_t, _b)   (((_t) & (1 << (_b))) != 0 ? true : false)
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:53:#define RTEMS_RFS_BITMAP_ELEMENT_CLEAR      (RTEMS_RFS_BITMAP_ELEMENT_FULL_MASK)
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:56:#define RTEMS_RFS_BITMAP_TEST_BIT(_t, _b)   (((_t) & (1 << (_b))) == 0 ? true : false)
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:65: * This is the full mask of the length of the element. A mask is always a 1 for
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:148: * compiler should figure this out but I would rather enforce this than rely on
cpukit/libfs/src/rfs/rtems-rfs-bitmaps.h:255: * search down from the seed for the window distance. This is repeated out from
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:89:      printf ("rtems-rfs: read-superblock: invalid superblock block/size count\n");
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:98:      printf ("rtems-rfs: read-superblock: incompatible version: %08" PRIx32 " (%08" PRIx32 ")\n",
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:107:      printf ("rtems-rfs: read-superblock: inode size mismatch: fs:%" PRId32 " target:%" PRId32 "\n",
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:136:      printf ("rtems-rfs: read-superblock: groups blocks larger than block bits\n");
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:150:      printf ("rtems-rfs: read-superblock: invalid superblock block size%d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:167:   * know how far the initialisation has gone if an error occurs and we need to
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:184:        printf ("rtems-rfs: read-superblock: no memory for group table%d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-file-system.c:299:      printf ("rtems-rfs: open: closing root inode: %d: %s\n", rc, strerror (rc));
cpukit/libfs/src/rfs/rtems-rfs-buffer.h:160: * Request a buffer. The buffer can be filled with data from the media (read ==
cpukit/libfs/src/rfs/rtems-rfs-buffer.h:176: * result does not indicate if the data was successfully written to the disk as
cpukit/libfs/src/rfs/rtems-rfs-buffer-bdbuf.c:68:    printf ("rtems-rfs: bdbuf-release: block=%" PRIuPTR " bdbuf=%" PRIu32 " %s\n",
cpukit/libfs/src/rfs/rtems-rfs-group.c:40:      printf ("rtems-rfs: group-open: base outside file system range: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-group.c:58:    printf ("rtems-rfs: group-open: base=%" PRId32 ", blocks=%zd inodes=%zd\n",
cpukit/libfs/src/rfs/rtems-rfs-group.c:68:      printf ("rtems-rfs: group-open: could not open block bitmap handle: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-group.c:75:                              group->base + RTEMS_RFS_GROUP_BLOCK_BITMAP_BLOCK);
cpukit/libfs/src/rfs/rtems-rfs-group.c:91:      printf ("rtems-rfs: group-open: could not open inode bitmap handle: %d: %s\n",
cpukit/libfs/src/rfs/rtems-rfs-group.c:98:                              group->base + RTEMS_RFS_GROUP_INODE_BITMAP_BLOCK);
cpukit/libfs/src/rfs/rtems-rfs-group.c:130:   * occurs but this may result in one even more important error being lost but
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:28:#define RTEMS_RFS_SB_OFFSET_VERSION         (RTEMS_RFS_SB_OFFSET_MAGIC           + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:29:#define RTEMS_RFS_SB_OFFSET_BLOCK_SIZE      (RTEMS_RFS_SB_OFFSET_VERSION         + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:30:#define RTEMS_RFS_SB_OFFSET_BLOCKS          (RTEMS_RFS_SB_OFFSET_BLOCK_SIZE      + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:31:#define RTEMS_RFS_SB_OFFSET_BAD_BLOCKS      (RTEMS_RFS_SB_OFFSET_BLOCKS          + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:32:#define RTEMS_RFS_SB_OFFSET_MAX_NAME_LENGTH (RTEMS_RFS_SB_OFFSET_BAD_BLOCKS      + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:33:#define RTEMS_RFS_SB_OFFSET_GROUPS          (RTEMS_RFS_SB_OFFSET_MAX_NAME_LENGTH + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:34:#define RTEMS_RFS_SB_OFFSET_GROUP_BLOCKS    (RTEMS_RFS_SB_OFFSET_GROUPS          + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:35:#define RTEMS_RFS_SB_OFFSET_GROUP_INODES    (RTEMS_RFS_SB_OFFSET_GROUP_BLOCKS    + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:36:#define RTEMS_RFS_SB_OFFSET_INODE_SIZE      (RTEMS_RFS_SB_OFFSET_GROUP_INODES    + 4)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:50: * The root inode number. Do not use 0 as this has special meaning in some Unix
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:61: * The number of blocks in the inode. This number effects the size of the inode
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:99:                                                 * off so they are released. */
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:103:                                                 * default is to hold buffers. */
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:237:   * List of buffers that need to be released modified when the processing of a
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:248:   * List of open shared file node data. The shared node data such as the inode
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:270:#define rtems_rfs_fs_release_bitmaps(_f) (!((_f)->flags & RTEMS_RFS_FS_BITMAPS_HOLD))
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:277:#define rtems_rfs_fs_no_local_cache(_f) ((_f)->flags & RTEMS_RFS_FS_NO_LOCAL_CACHE)
cpukit/libfs/src/rfs/rtems-rfs-file-system.h:356:#define rtems_rfs_fs_max_block_map_blocks(_fs) ((_fs)->block_map_doubly_blocks)
cpukit/libfs/src/rfs/rtems-rfs-group.h:33: * A group is a selection of blocks on the disk. Typically the number of blocks
cpukit/libfs/src/rfs/rtems-rfs-group.h:34: * in a group is determined by the number of bits a block holds. This makes the
cpukit/libfs/src/rfs/rtems-rfs-group.h:35: * bit allocator for blocks in the group simpler plus is allows a simple way to
cpukit/libfs/src/defaults/default_ops.c:24:const rtems_filesystem_operations_table rtems_filesystem_operations_default = {
cpukit/libfs/src/nfsclient/proto/mount_prot_xdr.c:51:	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct mountbody), (xdrproc_t) xdr_mountbody))
cpukit/libfs/src/nfsclient/proto/mount_prot_xdr.c:71:	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct groupnode), (xdrproc_t) xdr_groupnode))
cpukit/libfs/src/nfsclient/proto/mount_prot_xdr.c:89:	 if (!xdr_pointer (xdrs, (char **)objp, sizeof (struct exportnode), (xdrproc_t) xdr_exportnode))
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:8:/*static char sccsid[] = "from: @(#)nfs_prot.x 1.2 87/10/12 Copyr 1987 Sun Micro";*/
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:360:	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, NFS_MAXDATA))
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:404:		 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, NFS_MAXDATA))
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:424:		 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, NFS_MAXDATA))
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:437:	 if (!xdr_bytes (xdrs, (char **)&objp->data.data_val, (u_int *) &objp->data.data_len, NFS_MAXDATA))
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:513:	 if (!xdr_pointer (xdrs, (char **)&objp->nextentry, sizeof (entry), (xdrproc_t) xdr_entry))
cpukit/libfs/src/nfsclient/proto/nfs_prot_xdr.c:521:	 if (!xdr_pointer (xdrs, (char **)&objp->entries, sizeof (entry), (xdrproc_t) xdr_entry))
cpukit/libfs/src/nfsclient/src/rpcio.c:142:#define RTEMS_RPC_EVENT		RTEMS_EVENT_30	/* THE event used by RPCIO. Every task doing
cpukit/libfs/src/nfsclient/src/rpcio.c:146:#define RPCIOD_RX_EVENT		RTEMS_EVENT_1	/* Events the RPCIOD is using/waiting for */
cpukit/libfs/src/nfsclient/src/rpcio.c:148:#define RPCIOD_KILL_EVENT	RTEMS_EVENT_3	/* send to the daemon to kill it          */
cpukit/libfs/src/nfsclient/src/rpcio.c:163:#define DEBUG_PACKLOSS		(1<<4)	/* This introduces random, artificial packet losses to test retransmission */
cpukit/libfs/src/nfsclient/src/rpcio.c:192:#define XACT_HASHS		(1<<(LD_XACT_HASH))	/* the hash table size derived from the ld       */
cpukit/libfs/src/nfsclient/src/rpcio.c:193:#define XACT_HASH_MSK	((XACT_HASHS)-1)	/* mask to extract the hash index from a RPC-XID */
cpukit/libfs/src/nfsclient/src/rpcio.c:283:		unsigned long		retrans;		/* how many retries were issued by this server         */
cpukit/libfs/src/nfsclient/src/rpcio.c:284:		unsigned long		requests;		/* how many requests have been sent                    */
cpukit/libfs/src/nfsclient/src/rpcio.c:285:		unsigned long       timeouts;		/* how many requests have timed out                    */
cpukit/libfs/src/nfsclient/src/rpcio.c:286:		unsigned long       errors;         /* how many errors have occurred (other than timeouts) */
cpukit/libfs/src/nfsclient/src/rpcio.c:387:static RpcUdpServer		rpcUdpServers = 0;	/* linked list of all servers; protected by llock */
cpukit/libfs/src/nfsclient/src/rpcio.c:390:static rtems_id			rpciod  = 0;		/* task id of the RPC daemon                 */
cpukit/libfs/src/nfsclient/src/rpcio.c:396:static rtems_id			hlock	= 0;		/* MUTEX protecting the hash table and the list of servers */
cpukit/libfs/src/nfsclient/src/rpcio.c:401:static rtems_interval	ticksPerSec;		/* cached system clock rate (WHO IS ASSUMED NOT
cpukit/libfs/src/nfsclient/src/rpcio.c:973:			assert( 0==setsockopt(ourSock, SOL_SOCKET, SO_RCVWAKEUP, &wkup, sizeof(wkup)) );
cpukit/libfs/src/nfsclient/src/rpcio.c:1036:	if ( RPC_SUCCESS != (err=rpcUdpServerCreate(psaddr, prog, vers, uid, gid, &s)) )
cpukit/libfs/src/nfsclient/src/rpcio.c:1199:				fprintf(stderr,"RPCIO There are still transactions circulating; I refuse to go away\n");
cpukit/libfs/src/nfsclient/src/rpcio.c:1490:	for (xact=((RpcUdpXact)listHead.next); xact; xact=((RpcUdpXact)xact->node.next)) {
cpukit/libfs/src/nfsclient/src/rpcio.c:1605:recv_mbuf_from(int s, struct mbuf **ppm, long len, struct sockaddr *fromaddr, int *fromlen);
cpukit/libfs/src/nfsclient/src/rpcio.c:1735:			    xact->server->addr.sin.sin_addr.s_addr == fromAddr.sin.sin_addr.s_addr &&
cpukit/libfs/src/nfsclient/src/rpcio.c:1737:		        xact->server->addr.sin.sin_port        == fromAddr.sin.sin_port        &&
cpukit/libfs/src/nfsclient/src/rpcio.c:1742:			fprintf(stderr,"RPCIO - FYI sockRcv(): dropping late/redundant retry answer\n");
cpukit/libfs/src/nfsclient/src/rpcio.c:1757:					"RPCIO WARNING sockRcv(): got xid 0x%08" PRIx32 " but its slot is empty\n",
cpukit/libfs/src/nfsclient/src/librtemsNfs.h:160:rtems_filesystem_resolve_location(char *buf, int len, rtems_filesystem_location_info_t *loc);
cpukit/libfs/src/nfsclient/src/nfsTest.c:110:	int      size;		/* IN: block size to read (must be < 8192), OUT: bytes actually read */
cpukit/libfs/src/nfsclient/src/nfsTest.c:146:		sc = rtems_message_queue_receive(nfsTestRQ, &r, &s, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
cpukit/libfs/src/nfsclient/src/nfsTest.c:236:		rtems_message_queue_receive(nfsTestAQ, &r, &s, RTEMS_WAIT, RTEMS_NO_TIMEOUT);
cpukit/libfs/src/nfsclient/src/rpcio.h:199:	XactGetCreate	/* a new transaction is allocated (and freed when put back to the pool */
cpukit/libfs/src/nfsclient/src/xdr_mbuf.c:3:/* Author (mbuf specifica): Till Straumann <strauman@slac.stanford.edu>, 10/2002 */
cpukit/libfs/src/nfsclient/src/xdr_mbuf.c:35:/*static char *sccsid = "from: @(#)xdr_mem.c 1.19 87/08/11 Copyr 1984 Sun Micro";*/
cpukit/libfs/src/nfsclient/src/xdr_mbuf.c:37:static char *rcsid = "$FreeBSD: src/lib/libc/xdr/xdr_mem.c,v 1.8 1999/08/28 00:02:56 peter Exp $";
cpukit/libfs/src/nfsclient/src/xdr_mbuf.c:101:static u_int	xdrmbuf_getpos(XDR *xdrs); /* XXX w/64-bit pointers, u_int not enough! */
cpukit/libfs/src/nfsclient/src/xdr_mbuf.c:298:			fprintf(stderr,"Got unaligned long %x (%i remaining)\n",*lp, xdrs->x_handy);
cpukit/libfs/src/nfsclient/src/nfs.c:94:#define CONFIG_NFS_SMALL_XACT_SIZE		800			/* size of RPC arguments for non-write ops */
cpukit/libfs/src/nfsclient/src/nfs.c:166:			(((rtems_device_minor_number)((node)->nfs->id))<<16) | (((rtems_device_minor_number)SERP_ATTR((node)).fileid) >> 16) )
cpukit/libfs/src/nfsclient/src/nfs.c:173:			(((rtems_device_minor_number)((node)->nfs->id))<<16) | (SERP_ATTR((node)).fsid & (((rtems_device_minor_number)1<<16)-1)) )
cpukit/libfs/src/nfsclient/src/nfs.c:359:		if ( !xdr_pointer(xdrs, (void*)&dip, 0 /* size */, (xdrproc_t)xdr_dir_info_entry) )
cpukit/libfs/src/nfsclient/src/nfs.c:617:rtems_filesystem_resolve_location(char *buf, int len, rtems_filesystem_location_info_t *loc);
cpukit/libfs/src/nfsclient/src/nfs.c:1014:	if (RTEMS_SUCCESSFUL != rtems_io_register_driver(0, &drvNfs, &nfsGlob.nfs_major)) {
cpukit/libfs/src/nfsclient/src/nfs.c:1068:			"WARNING: Using 'short st_ino' hits performance and may fail to access/find correct files\n");
cpukit/libfs/src/nfsclient/src/nfs.c:1726:	/* print counts at entry where they are > 0 so 'nfs' is safe from being destroyed
cpukit/libfs/src/nfsclient/src/nfs.c:2117:	SERP_ARGS(node).symlinkarg.attributes.mode	= S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
cpukit/libfs/src/nfsclient/src/nfs.c:2927:		if (rtems_filesystem_resolve_location(mntpt, MAXPATHLEN, &nfs->mt_entry->mt_fs_root->location))
cpukit/libfs/src/nfsclient/src/nfs.c:2957:		fprintf(stderr,"usage: nfsMount(""[uid.gid@]host"",""path"",""mountpoint"")\n");
cpukit/libfs/src/nfsclient/src/nfs.c:3064:	/* IMPORTANT: let the helper task have its own libio environment (i.e. cwd) */
cpukit/libfs/src/nfsclient/src/nfs.c:3092:rtems_filesystem_resolve_location(char *buf, int len, rtems_filesystem_location_info_t *loc)
cpukit/libfs/src/dosfs/fat.c:121:            memcpy(fs_info->sec_buf, fs_info->c.buf->buffer, fs_info->vol.bps);
cpukit/libfs/src/dosfs/fat.c:485:    vol->rdir_secs = ((vol->rdir_entrs * FAT_DIRENTRY_SIZE) + (vol->bps - 1)) /
cpukit/libfs/src/dosfs/fat.c:537:        vol->mirror = FAT_GET_BR_EXT_FLAGS(boot_rec) & FAT_BR_EXT_FLAGS_MIRROR;
cpukit/libfs/src/dosfs/fat.c:539:            vol->afat = FAT_GET_BR_EXT_FLAGS(boot_rec) & FAT_BR_EXT_FLAGS_FAT_NUM;
cpukit/libfs/src/dosfs/fat.c:855:        if ((fs_info->uino_pool_size << 1) < (0x0FFFFFFF - fs_info->uino_base))
cpukit/libfs/src/dosfs/fat_file.h:61:                                     * fat-file descriptors organized into hash;
cpukit/libfs/src/dosfs/msdos_dir.c:201:                ((*MSDOS_DIR_ATTR(entry) & MSDOS_ATTR_LFN_MASK) != MSDOS_ATTR_LFN))
cpukit/libfs/src/dosfs/msdos_dir.c:263:                 * trailing nul character. We need to range check the length to
cpukit/libfs/src/dosfs/msdos_create.c:41: *     new directory and dot and dotdot nodes are created in alloceted cluster.
cpukit/libfs/src/dosfs/msdos_create.c:140:      *MSDOS_DIR_CRT_TIME_TENTH(short_node)=*MSDOS_DIR_CRT_TIME_TENTH(link_node);
cpukit/libfs/src/dosfs/msdos_create.c:220:                CT_LE_W((uint16_t  )(((parent_fat_fd->cln) & 0xFFFF0000)>>16));
cpukit/libfs/src/dosfs/msdos.h:39:                                                                 * a set of routines
cpukit/libfs/src/dosfs/msdos.h:40:                                                                 * that handles the
cpukit/libfs/src/dosfs/msdos.h:41:                                                                 * nodes of directory
cpukit/libfs/src/dosfs/msdos.h:45:                                                            * a set of routines
cpukit/libfs/src/dosfs/msdos.h:101:                          ((uint32_t)(CF_LE_W((*MSDOS_DIR_FIRST_CLUSTER_HI(p))))<<16) )
cpukit/libfs/src/dosfs/msdos.h:180:extern const char *const MSDOS_DOT_NAME;    /* ".", padded to MSDOS_NAME chars */
cpukit/libfs/src/dosfs/msdos.h:181:extern const char *const MSDOS_DOTDOT_NAME; /* ".", padded to MSDOS_NAME chars */
cpukit/libfs/src/dosfs/msdos_format.c:302:  while (MS_BYTES_PER_CLUSTER_LIMIT / bytes_per_sector < sectors_per_cluster) {
cpukit/libfs/src/dosfs/msdos_format.c:376: msdos_format_param_t               *fmt_params/* computed fmt parameters        */
cpukit/libfs/src/dosfs/msdos_format.c:404:                         "bytes per sector: %" PRIu32 "\ntotal sectors: %" PRIu32 "\ntotal size: %" PRIu64 "\n",
cpukit/libfs/src/dosfs/msdos_format.c:405:                         fmt_params->bytes_per_sector, fmt_params->totl_sector_cnt, total_size);
cpukit/libfs/src/dosfs/msdos_format.c:547:                         "sectors per cluster: %d\n", fmt_params->sectors_per_cluster);
cpukit/libfs/src/dosfs/msdos_format.c:561:      /* recommended: for FAT12/FAT16, always set reserved sector count to 1 */
cpukit/libfs/src/dosfs/msdos_format.c:764:  memset(mbr + RTEMS_IDE_PARTITION_TABLE_OFFSET + RTEMS_IDE_PARTITION_TABLE_SIZE,
cpukit/libfs/src/dosfs/msdos_format.c:766:         FAT_TOTAL_MBR_SIZE - (RTEMS_IDE_PARTITION_TABLE_OFFSET + RTEMS_IDE_PARTITION_TABLE_SIZE));
cpukit/libfs/src/dosfs/msdos_format.c:813:    FAT_SET_BR_FAT32_BK_BOOT_SECTOR(mbr, fmt_params->mbr_copy_sec ); /* Put MBR copy to rsrvd sec */
cpukit/libfs/src/dosfs/fat.h:295:    uint8_t            sec_mul;        /* log2 of 512bts sectors number per sector */
cpukit/libfs/src/dosfs/fat.h:313:    uint32_t           rdir_cl;        /* first cluster of the root directory */
cpukit/libfs/src/dosfs/fat_file.c:62: *     First, hash table("vhash") consists of fat-file descriptors corresponded
cpukit/libfs/src/dosfs/fat_file.c:371:    uint32_t       save_cln = 0; /* FIXME: This might be incorrect, cf. below */
cpukit/libfs/src/dosfs/msdos_misc.c:296:     * find the node which correspondes to the name in the directory pointed by
cpukit/libfs/src/dosfs/msdos_misc.c:305:        ((*MSDOS_DIR_ATTR(node_entry) & MSDOS_ATTR_LFN_MASK) == MSDOS_ATTR_LFN))
cpukit/libfs/src/dosfs/msdos_misc.c:438:         * Really, we should return cluster num and offset not of ".." slot, but
cpukit/libfs/src/dosfs/msdos_misc.c:451:                     * we can relax about first_char field - it never should be
cpukit/libfs/src/dosfs/msdos_misc.c:460:                        msdos_get_dotdot_dir_info_cluster_num_and_offset(parent_loc->mt_entry,
cpukit/libfs/src/dosfs/msdos_misc.c:461:                                                                         dotdot_cln,
cpukit/libfs/src/dosfs/msdos_misc.c:462:                                                                         dir_pos,
cpukit/libfs/src/dosfs/msdos_misc.c:463:                                                                         name_dir_entry);
cpukit/libfs/src/dosfs/msdos_misc.c:487: *     Get cluster num and offset not of ".." slot, but slot which correspondes
cpukit/libfs/src/dosfs/msdos_misc.c:647:    sec = fat_cluster_num_to_sector_num(&fs_info->fat, fat_fd->dir_pos.sname.cln);
cpukit/libfs/src/dosfs/msdos_misc.c:653:    ret1 = _fat_block_write(&fs_info->fat, sec, byte + MSDOS_FILE_WTIME_OFFSET,
cpukit/libfs/src/dosfs/msdos_misc.c:656:    ret2 = _fat_block_write(&fs_info->fat, sec, byte + MSDOS_FILE_WDATE_OFFSET,
cpukit/libfs/src/dosfs/msdos_misc.c:658:    ret3 = _fat_block_write(&fs_info->fat, sec, byte + MSDOS_FILE_ADATE_OFFSET,
cpukit/libfs/src/dosfs/msdos_misc.c:697:    sec = fat_cluster_num_to_sector_num(&fs_info->fat, fat_fd->dir_pos.sname.cln);
cpukit/libfs/src/dosfs/msdos_misc.c:740:    sec = fat_cluster_num_to_sector_num(&fs_info->fat, fat_fd->dir_pos.sname.cln);
cpukit/libfs/src/dosfs/msdos_misc.c:745:    ret = _fat_block_write(&fs_info->fat, sec, byte + MSDOS_FILE_SIZE_OFFSET, 4,
cpukit/libfs/src/dosfs/msdos_misc.c:801:      uint32_t sec = (fat_cluster_num_to_sector_num(&fs_info->fat, start.cln) +
cpukit/libfs/src/dosfs/msdos_misc.c:805:      ret = _fat_block_write(&fs_info->fat, sec, byte + MSDOS_FILE_NAME_OFFSET,
cpukit/libfs/src/dosfs/msdos_misc.c:831: *     Check whether directory which correspondes to the fat-file descriptor is
cpukit/libfs/src/dosfs/msdos_misc.c:857:    while ((ret = fat_file_read(&fs_info->fat, fat_fd, j * fs_info->fat.vol.bps,
cpukit/libfs/src/dosfs/msdos_misc.c:877:             * Just ignore long file name entries. They must have a short entry to
cpukit/libfs/src/dosfs/msdos_misc.c:1032:                    dir_entry, (dir_entry / MSDOS_DIRECTORY_ENTRY_STRUCT_SIZE));
cpukit/libfs/src/dosfs/msdos_misc.c:1050:                printf ("MSFS:[3.1] cn:%i esf:%i\n", create_node, empty_space_found);
cpukit/libfs/src/dosfs/msdos_misc.c:1060:                 * Lets go and write the directory entries. If we have not found
cpukit/libfs/src/dosfs/msdos_misc.c:1061:                 * any available space add the remaining number of entries to any that
cpukit/libfs/src/dosfs/msdos_misc.c:1062:                 * we may have already found that are just before this entry. If more
cpukit/libfs/src/dosfs/msdos_misc.c:1063:                 * are needed FAT_EOF is returned by the read and we extend the file.
cpukit/libfs/src/dosfs/msdos_misc.c:1068:                    entries_per_block - (dir_entry / MSDOS_DIRECTORY_ENTRY_STRUCT_SIZE);
cpukit/libfs/src/dosfs/msdos_misc.c:1071:                  printf ("MSFS:[3.2] esf:%i esc%i\n", empty_space_found, empty_space_count);
cpukit/libfs/src/dosfs/msdos_misc.c:1120:                            *MSDOS_DIR_ENTRY_TYPE(entry) & MSDOS_LAST_LONG_ENTRY_MASK,
cpukit/libfs/src/dosfs/msdos_misc.c:1191:                        printf ("MSFS:[6] o:%i i:%i *p:%c(%02x) name[o + i]:%c(%02x)\n",
cpukit/libfs/src/dosfs/msdos_misc.c:1197:                             * If this is the first entry, ie the last part of the
cpukit/libfs/src/dosfs/msdos_misc.c:1198:                             * long file name and the length does not match then
cpukit/libfs/src/dosfs/msdos_misc.c:1237:                    printf ("MSFS:[9.1] SFN entry, lfn_matched:%i\n", lfn_matched);
cpukit/libfs/src/dosfs/msdos_misc.c:1259:                        printf ("MSFS:[9.2] checksum, lfn_matched:%i, lfn_entry:%i, lfn_checksum:%02x/%02x\n",
cpukit/libfs/src/dosfs/msdos_misc.c:1266:                     * short and they match then we have the entry. We will not
cpukit/libfs/src/dosfs/msdos_misc.c:1267:                     * match a long file name against a short file name because
cpukit/libfs/src/dosfs/msdos_misc.c:1285:                        int rc = fat_file_ioctl(&fs_info->fat, fat_fd, F_CLU_NUM,
cpukit/libfs/src/dosfs/msdos_misc.c:1295:                          rc = fat_file_ioctl(&fs_info->fat, fat_fd, F_CLU_NUM,
cpukit/libfs/src/dosfs/msdos_misc.c:1330:            dir_offset, empty_space_count, empty_space_offset, empty_space_entry);
cpukit/libfs/src/dosfs/msdos_misc.c:1419:            printf ("MSFS:[9.3] extended: %d <-> %d\n", new_length, empty_space_offset * bts2rd);
cpukit/libfs/src/dosfs/msdos_misc.c:1458:                    dir_entry, (dir_entry / MSDOS_DIRECTORY_ENTRY_STRUCT_SIZE),
cpukit/libfs/src/dosfs/msdos_misc.c:1550:                             (empty_space_offset * bts2rd) + empty_space_entry,
cpukit/libfs/src/dosfs/msdos_misc.c:1629:                rc = fat_file_ioctl(&fs_info->fat, fat_fd, F_CLU_NUM, j * bts2rd,
cpukit/libfs/src/devfs/devstat.c:22:    buf->st_rdev = rtems_filesystem_make_dev_t( the_dev->major, the_dev->minor );
cpukit/libfs/src/devfs/devfs.h:21:  /** This member points to device name which is not a null-terminated string */
cpukit/libfs/src/devfs/devfs.h:143: *  This handler gets the device file information. This routine only set the following member of struct stat:
cpukit/libfs/src/devfs/devfs_show.c:15:  rtems_filesystem_location_info_t *rootloc = &rtems_filesystem_root->location;
cpukit/zlib/inffast.c:236:                            if (wnext < len) {  /* some from start of window */
cpukit/zlib/inffast.c:309:    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
cpukit/zlib/inffast.c:318:    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
cpukit/zlib/infback.c:64:   Return state with length and distance decoding tables and index sizes set to
cpukit/zlib/infback.c:70:   used for threaded applications, since the rewriting of the tables and virgin
cpukit/zlib/infback.c:448:            /* build code tables -- note: do not change the lenbits or distbits
cpukit/zlib/infback.c:449:               values here (9 and 6) without reading the comments in inftrees.h
cpukit/zlib/infback.c:450:               concerning the ENOUGH constants, which depend on those values */
cpukit/zlib/infback.c:454:            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
cpukit/zlib/infback.c:463:            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
cpukit/zlib/infback.c:575:            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
cpukit/zlib/infback.c:626:    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
cpukit/zlib/trees.c:60:local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
cpukit/zlib/trees.c:66:local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
cpukit/zlib/trees.c:352:    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
cpukit/zlib/trees.c:951:        /* Build the bit length tree for the above two trees, and get the index
cpukit/zlib/trees.c:1027:    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
cpukit/zlib/trees.c:1098:                send_bits(s, lc, extra);       /* send the extra length bits */
cpukit/zlib/trees.c:1108:                send_bits(s, dist, extra);   /* send the extra distance bits */
cpukit/zlib/trees.c:1112:        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
cpukit/zlib/trees.c:1159:     * this stream either is empty or has tolerated ("gray-listed") bytes only.
cpukit/zlib/adler32.c:57:/* ========================================================================= */
cpukit/zlib/adler32.c:128:/* ========================================================================= */
cpukit/zlib/adler32.c:144:    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
cpukit/zlib/adler32.c:152:/* ========================================================================= */
cpukit/zlib/uncompr.c:49:        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
cpukit/zlib/gzread.c:18:   state->fd, and update state->eof, state->err, and state->msg as appropriate.
cpukit/zlib/gzread.c:46:   error, 0 otherwise.  Note that the eof flag is set when the end of the input
cpukit/zlib/gzread.c:92:/* Look for gzip header, set up for inflate or copy.  state->have must be zero.
cpukit/zlib/gzread.c:94:   left unchanged if there is no more input data available, will be set to COPY
cpukit/zlib/gzread.c:99:   the output buffer.  In that case, all further file reads will be directly to
cpukit/zlib/gzread.c:265:                      strm->msg == NULL ? "compressed data error" : strm->msg);
cpukit/zlib/gzread.c:289:        state->how = LOOK;      /* ready for next stream, once have is 0 (leave
cpukit/zlib/gzread.c:300:   looked for (and skipped if found) to determine wither to copy or decompress.
cpukit/zlib/gzread.c:316:        if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)
cpukit/zlib/gzread.c:329:/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
cpukit/zlib/inflate.h:36:        COPY,       /* i/o: waiting for input or output to copy stored block */
cpukit/zlib/inflate.h:87:    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
cpukit/zlib/crc32.c:16:  first call get_crc_table() to initialize the tables before allowing more than
cpukit/zlib/crc32.c:102:  combinations of CRC register values and incoming bytes.  The remaining tables
cpukit/zlib/crc32.c:214:/* ========================================================================= */
cpukit/zlib/crc32.c:218:/* ========================================================================= */
cpukit/zlib/crc32.c:255:/* ========================================================================= */
cpukit/zlib/crc32.c:261:/* ========================================================================= */
cpukit/zlib/crc32.c:295:/* ========================================================================= */
cpukit/zlib/crc32.c:301:/* ========================================================================= */
cpukit/zlib/crc32.c:341:/* ========================================================================= */
cpukit/zlib/crc32.c:358:/* ========================================================================= */
cpukit/zlib/crc32.c:369:/* ========================================================================= */
cpukit/zlib/crc32.c:425:/* ========================================================================= */
cpukit/zlib/inftrees.h:38:/* Maximum size of the dynamic table.  The maximum number of code structures is
cpukit/zlib/inftrees.h:46:   inflate_table() calls in inflate.c and infback.c.  If the root table size is
cpukit/zlib/trees.h:74: 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
cpukit/zlib/trees.h:75: 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
cpukit/zlib/trees.h:76:10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
cpukit/zlib/trees.h:77:11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
cpukit/zlib/trees.h:78:12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
cpukit/zlib/trees.h:79:13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
cpukit/zlib/trees.h:80:13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
cpukit/zlib/trees.h:81:14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
cpukit/zlib/trees.h:82:14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
cpukit/zlib/trees.h:83:14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
cpukit/zlib/trees.h:84:15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
cpukit/zlib/trees.h:85:15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
cpukit/zlib/trees.h:86:15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
cpukit/zlib/trees.h:87:18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
cpukit/zlib/trees.h:88:23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
cpukit/zlib/trees.h:89:24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
cpukit/zlib/trees.h:90:26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
cpukit/zlib/trees.h:91:26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
cpukit/zlib/trees.h:92:27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
cpukit/zlib/trees.h:93:27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
cpukit/zlib/trees.h:94:28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
cpukit/zlib/trees.h:95:28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
cpukit/zlib/trees.h:96:28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
cpukit/zlib/trees.h:97:29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
cpukit/zlib/trees.h:98:29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
cpukit/zlib/trees.h:103: 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
cpukit/zlib/trees.h:104:13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
cpukit/zlib/trees.h:105:17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
cpukit/zlib/trees.h:106:19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
cpukit/zlib/trees.h:107:21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
cpukit/zlib/trees.h:108:22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
cpukit/zlib/trees.h:109:23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
cpukit/zlib/trees.h:110:24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
cpukit/zlib/trees.h:111:25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
cpukit/zlib/trees.h:112:25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
cpukit/zlib/trees.h:113:26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
cpukit/zlib/trees.h:114:26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
cpukit/zlib/inflate.c:26: * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
cpukit/zlib/inflate.c:34: * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
cpukit/zlib/inflate.c:231:   Return state with length and distance decoding tables and index sizes set to
cpukit/zlib/inflate.c:237:   used for threaded applications, since the rewriting of the tables and virgin
cpukit/zlib/inflate.c:289:   those tables to stdout, which would be piped to inffixed.h.  A small program
cpukit/zlib/inflate.c:347:   when a window is already in use, or when output has been written during this
cpukit/zlib/inflate.c:352:   Providing output buffers larger than 32K to inflate() should provide a speed
cpukit/zlib/inflate.c:353:   advantage, since only the last 32K of output is copied to the sliding window
cpukit/zlib/inflate.c:355:   output will fall in the output data, making match copies simpler and faster.
cpukit/zlib/inflate.c:508:   inflate() uses a state machine to process as much input data and generate as
cpukit/zlib/inflate.c:572:   Progress is defined as a change in either strm->avail_in or strm->avail_out.
cpukit/zlib/inflate.c:580:   strm->next_out, given the space available and the provided input--the effect
cpukit/zlib/inflate.c:979:            /* build code tables -- note: do not change the lenbits or distbits
cpukit/zlib/inflate.c:980:               values here (9 and 6) without reading the comments in inftrees.h
cpukit/zlib/inflate.c:981:               concerning the ENOUGH constants, which depend on those values */
cpukit/zlib/inflate.c:985:            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
cpukit/zlib/inflate.c:994:            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
cpukit/zlib/inflate.c:1106:            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
cpukit/zlib/inflate.c:1242:    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
cpukit/zlib/zlib.h:49:  decompression functions, including integrity checks of the uncompressed data.
cpukit/zlib/zlib.h:132:     The application must update next_in and avail_in when avail_in has dropped
cpukit/zlib/zlib.h:147:     On 16-bit systems, the functions zalloc and zfree must be able to allocate
cpukit/zlib/zlib.h:149:   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
cpukit/zlib/zlib.h:151:   offset normalized to zero.  The default allocation function provided by this
cpukit/zlib/zlib.h:152:   library ensures this (see zutil.c).  To reduce memory requirements and avoid
cpukit/zlib/zlib.h:158:   uncompressed data and may be saved for use in the decompressor (particularly
cpukit/zlib/zlib.h:241:   if there is no error message.  deflateInit does not perform any compression:
cpukit/zlib/zlib.h:253:    The detailed semantics are as follows.  deflate performs one or both of the
cpukit/zlib/zlib.h:268:  one of the actions is possible, by providing more input and/or consuming more
cpukit/zlib/zlib.h:281:  flushed to the output buffer and the output is aligned on a byte boundary, so
cpukit/zlib/zlib.h:286:  completes the current deflate block and follows it with an empty stored block
cpukit/zlib/zlib.h:292:  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
cpukit/zlib/zlib.h:295:  in order for the decompressor to finish the block before the empty fixed code
cpukit/zlib/zlib.h:299:  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
cpukit/zlib/zlib.h:300:  seven bits of the current block are held to be written as the next byte after
cpukit/zlib/zlib.h:303:  the data provided so far to the compressor.  It may need to wait for the next
cpukit/zlib/zlib.h:310:  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
cpukit/zlib/zlib.h:325:  deflate has returned Z_STREAM_END, the only possible operations on the stream
cpukit/zlib/zlib.h:329:  is to be done in a single step.  In this case, avail_out must be at least the
cpukit/zlib/zlib.h:375:   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
cpukit/zlib/zlib.h:379:   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
cpukit/zlib/zlib.h:383:   apart from possibly reading the zlib header if present: actual decompression
cpukit/zlib/zlib.h:385:   next_out and avail_out are unused and unchanged.) The current implementation
cpukit/zlib/zlib.h:386:   of inflateInit() does not process any header information -- that is deferred
cpukit/zlib/zlib.h:407:    accordingly.  inflate() provides as much output as possible, until there is
cpukit/zlib/zlib.h:412:  one of the actions is possible, by providing more input and/or consuming more
cpukit/zlib/zlib.h:420:    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
cpukit/zlib/zlib.h:435:  stream.  The end-of-block will not be indicated until all of the uncompressed
cpukit/zlib/zlib.h:463:  first call.  So the only effect of the flush parameter in this implementation
cpukit/zlib/zlib.h:464:  is on the return value of inflate(), as noted below, or when it returns early
cpukit/zlib/zlib.h:467:     If a preset dictionary is needed after this call (see inflateSetDictionary
cpukit/zlib/zlib.h:471:  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
cpukit/zlib/zlib.h:483:    inflate() returns Z_OK if some progress has been made (more input processed
cpukit/zlib/zlib.h:486:  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
cpukit/zlib/zlib.h:490:  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
cpukit/zlib/zlib.h:491:  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
cpukit/zlib/zlib.h:525:     This is another version of deflateInit with more compression options.  The
cpukit/zlib/zlib.h:538:     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
cpukit/zlib/zlib.h:540:   with no zlib header or trailer, and will not compute an adler32 check value.
cpukit/zlib/zlib.h:545:   file name, no extra data, no comment, no modification time (set to zero), no
cpukit/zlib/zlib.h:555:     The strategy parameter is used to tune the compression algorithm.  Use the
cpukit/zlib/zlib.h:564:   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
cpukit/zlib/zlib.h:574:   set to null if there is no error message.  deflateInit2 does not perform any
cpukit/zlib/zlib.h:584:   immediately after deflateInit, deflateInit2 or deflateReset, before any call
cpukit/zlib/zlib.h:589:   to be encountered later in the data to be compressed, with the most commonly
cpukit/zlib/zlib.h:591:   dictionary is most useful when the data to be compressed is short and can be
cpukit/zlib/zlib.h:598:   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
cpukit/zlib/zlib.h:612:   inconsistent (for example if deflate has already been called for this stream
cpukit/zlib/zlib.h:624:   data with a filter.  The streams that will be discarded should then be freed
cpukit/zlib/zlib.h:626:   compression state which can be quite large, so this strategy is slow and can
cpukit/zlib/zlib.h:690:   to allocate an output buffer for deflation in a single pass, and so would be
cpukit/zlib/zlib.h:700:   leftover from a previous deflate stream when appending to it.  As such, this
cpukit/zlib/zlib.h:701:   function can only be used for raw deflate, and must be used before the first
cpukit/zlib/zlib.h:717:   in the provided gz_header structure are written to the gzip header (xflag is
cpukit/zlib/zlib.h:718:   ignored -- the extra flags are set according to the compression level).  The
cpukit/zlib/zlib.h:719:   caller must assure that, if not Z_NULL, name and comment are terminated with
cpukit/zlib/zlib.h:721:   available there.  If hcrc is true, a gzip header crc is included.  Note that
cpukit/zlib/zlib.h:722:   the current versions of the command-line version of gzip (up through version
cpukit/zlib/zlib.h:723:   1.3.x) do not support header crc's, and will report that it is a "multi-part
cpukit/zlib/zlib.h:728:   fields.  The gzip header is returned to the default state by deflateReset().
cpukit/zlib/zlib.h:744:   this version of the library.  The default value is 15 if inflateInit is used
cpukit/zlib/zlib.h:751:     windowBits can also be zero to request that inflate use the window size in
cpukit/zlib/zlib.h:754:     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
cpukit/zlib/zlib.h:756:   not looking for a zlib or gzip header, not generating a check value, and not
cpukit/zlib/zlib.h:763:   most applications, the zlib format should be used as is.  Note that comments
cpukit/zlib/zlib.h:769:   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
cpukit/zlib/zlib.h:773:   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
cpukit/zlib/zlib.h:777:   apart from possibly reading the zlib header if present: actual decompression
cpukit/zlib/zlib.h:779:   next_out and avail_out are unused and unchanged.) The current implementation
cpukit/zlib/zlib.h:789:   sequence.  This function must be called immediately after a call of inflate,
cpukit/zlib/zlib.h:812:     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
cpukit/zlib/zlib.h:815:   success case, the application may save the current current value of total_in
cpukit/zlib/zlib.h:868:   inflateReset().  bits must be less than or equal to 16, and that many of the
cpukit/zlib/zlib.h:886:   If the upper value is -1 and the lower value is non-zero, then inflate is in
cpukit/zlib/zlib.h:894:     A code is being processed if inflate is waiting for more input to complete
cpukit/zlib/zlib.h:917:   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
cpukit/zlib/zlib.h:930:   terminated with a zero unless the length is greater than comm_max.  When any
cpukit/zlib/zlib.h:940:   CRC if present.  inflateReset() will reset the process to discard the header
cpukit/zlib/zlib.h:941:   information.  The application would need to call inflateGetHeader() again to
cpukit/zlib/zlib.h:952:     Initialize the internal stream state for decompression using inflateBack()
cpukit/zlib/zlib.h:958:   assured that deflate was used with small window sizes, windowBits must be 15
cpukit/zlib/zlib.h:1003:   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
cpukit/zlib/zlib.h:1006:   case--and inflateBack() will return a buffer error.  inflateBack() will call
cpukit/zlib/zlib.h:1007:   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
cpukit/zlib/zlib.h:1018:   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
cpukit/zlib/zlib.h:1020:   must also be initialized, and then if strm->avail_in is not zero, input will
cpukit/zlib/zlib.h:1031:   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
cpukit/zlib/zlib.h:1032:   in the deflate stream (in which case strm->msg is set to indicate the nature
cpukit/zlib/zlib.h:1033:   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
cpukit/zlib/zlib.h:1035:   using strm->next_in which will be Z_NULL only if in() returned an error.  If
cpukit/zlib/zlib.h:1036:   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
cpukit/zlib/zlib.h:1085:     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
cpukit/zlib/zlib.h:1106:   the byte length of the source buffer.  Upon entry, destLen is the total size
cpukit/zlib/zlib.h:1143:   the byte length of the source buffer.  Upon entry, destLen is the total size
cpukit/zlib/zlib.h:1147:   mechanism outside the scope of this compression library.) Upon exit, destLen
cpukit/zlib/zlib.h:1177:   written be appended to the file.  "+" will result in an error, since reading
cpukit/zlib/zlib.h:1192:     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
cpukit/zlib/zlib.h:1194:   has been previously opened with fopen).  The mode parameter is as in gzopen.
cpukit/zlib/zlib.h:1197:   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
cpukit/zlib/zlib.h:1228:     Dynamically update the compression level or strategy.  See the description
cpukit/zlib/zlib.h:1231:     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
cpukit/zlib/zlib.h:1237:     Reads the given number of uncompressed bytes from the compressed file.  If
cpukit/zlib/zlib.h:1241:     After reaching the end of a gzip stream in the input, gzread will continue
cpukit/zlib/zlib.h:1262:   control of the format string, as in fprintf.  gzprintf returns the number of
cpukit/zlib/zlib.h:1268:   unpredictable consequences, which is possible only if zlib was compiled with
cpukit/zlib/zlib.h:1269:   the insecure functions sprintf() or vsprintf() because the secure snprintf()
cpukit/zlib/zlib.h:1284:     Reads bytes from the compressed file until len-1 characters are read, or a
cpukit/zlib/zlib.h:1291:   for end-of-file or in case of error.  If there was an error, the contents at
cpukit/zlib/zlib.h:1297:     Writes c, converted to an unsigned char, into the compressed file.  gzputc
cpukit/zlib/zlib.h:1326:   gzip stream is completed in the output.  If gzwrite() is called again, a new
cpukit/zlib/zlib.h:1375:     Returns the current offset in the file being read or written.  This offset
cpukit/zlib/zlib.h:1378:   does not include as yet unused buffered input.  This information can be used
cpukit/zlib/zlib.h:1385:   false (0) otherwise.  Note that the end-of-file indicator is set only if the
cpukit/zlib/zlib.h:1392:     If gzeof() returns true, then the read functions will return no more data,
cpukit/zlib/zlib.h:1393:   unless the end-of-file indicator is reset by gzclearerr() and the input file
cpukit/zlib/zlib.h:1400:   (0) if file is a gzip stream being decompressed.  This state can change from
cpukit/zlib/zlib.h:1409:   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
cpukit/zlib/zlib.h:1431:   compression or decompression code that is not used when only reading or only
cpukit/zlib/zlib.h:1433:   decompression code will be included the application when linking to a static
cpukit/zlib/zlib.h:1455:     Clears the error and end-of-file flags for file.  This is analogous to the
cpukit/zlib/zlib.h:1492:     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
cpukit/zlib/zlib.h:1494:   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
cpukit/zlib/zlib.h:1503:   complement) is performed within this function so it shouldn't be done by the
cpukit/zlib/zlib.h:1517:ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
cpukit/zlib/gzguts.h:74:/* gzip modes, also provide a little integrity check on the passed structure */
cpukit/zlib/gzguts.h:108:    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
cpukit/zlib/zutil.h:237:   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
cpukit/zlib/inftrees.c:293:       Fill in rest of table for incomplete codes.  This loop is similar to the
cpukit/zlib/inftrees.c:296:       through high index bits.  When the current sub-table is filled, the loop
cpukit/zlib/deflate.h:112:    /* Sliding window. Input bytes are read into the second half of the window,
cpukit/zlib/deflate.h:159:    /* Length of the best match at previous step. Matches not greater than this
cpukit/zlib/deflate.h:192:    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
cpukit/zlib/deflate.h:219:     *     data is still in the window so we can still emit a stored block even
cpukit/zlib/deflate.h:222:     *   - if compression is not successful for a file smaller than 64K, we can
cpukit/zlib/deflate.h:292:int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
cpukit/zlib/deflate.c:29: *      files if the parameter max_chain_length (described below) is too large.
cpukit/zlib/deflate.c:67:    finish_started, /* finish started, need only more output at next deflate */
cpukit/zlib/deflate.c:195:/* ========================================================================= */
cpukit/zlib/deflate.c:207:/* ========================================================================= */
cpukit/zlib/deflate.c:262:    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
cpukit/zlib/deflate.c:308:/* ========================================================================= */
cpukit/zlib/deflate.c:331:        dictionary += dictLength - length; /* use the tail of the dictionary */
cpukit/zlib/deflate.c:350:/* ========================================================================= */
cpukit/zlib/deflate.c:386:/* ========================================================================= */
cpukit/zlib/deflate.c:397:/* ========================================================================= */
cpukit/zlib/deflate.c:409:/* ========================================================================= */
cpukit/zlib/deflate.c:432:    if ((strategy != s->strategy || func != configuration_table[level].func) &&
cpukit/zlib/deflate.c:448:/* ========================================================================= */
cpukit/zlib/deflate.c:479: * This function could be more sophisticated to provide closer upper bounds for
cpukit/zlib/deflate.c:579:/* ========================================================================= */
cpukit/zlib/deflate.c:856:              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
cpukit/zlib/deflate.c:892:/* ========================================================================= */
cpukit/zlib/deflate.c:1070:    int nice_match = s->nice_match;             /* stop if match long enough */
cpukit/zlib/deflate.c:1092:    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
cpukit/zlib/deflate.c:1106:    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
cpukit/zlib/deflate.c:1219:    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
cpukit/zlib/deflate.c:1224:    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
cpukit/zlib/deflate.c:1312:        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
cpukit/zlib/deflate.c:1328:         * move the upper half to the lower one to make room in the upper half.
cpukit/zlib/deflate.c:1339:               to keep the hash table consistent if we switch back to level > 0
cpukit/zlib/deflate.c:1366:         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
cpukit/zlib/deflate.c:1396:     * written, then zero those bytes in order to avoid memory check reports of
cpukit/zlib/deflate.c:1399:     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
cpukit/zlib/deflate.c:1417:            /* High water mark at or above current data, but below current data
cpukit/zlib/deflate.c:1674:        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
cpukit/zlib/gzwrite.c:57:   flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,
cpukit/zlib/gzclose.c:9:   That way the other gzclose functions can be used instead to avoid linking in
cpukit/zlib/gzlib.c:321:    /* calculate skip amount, rewinding if needed for back seek when reading */
cpukit/zlib/gzlib.c:323:        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
cpukit/zlib/gzlib.c:483:   allocation failure constructing the error message, then convert the error to
cpukit/zlib/gzlib.c:509:    if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {
